cinclude "math.h";
import "io.rf";

/*
    Functions
    @author: Mr. Hecker (Stolen from the C standard library)
*/
native double acos(double x);
native float acosf(float x);
native double acosh(double x);
native float acoshf(float x);
native double asin(double x);
native float asinf(float x);
native double asinh(double x);
native float asinhf(float x);
native double atan(double x);
native double atan2(double x, double y);
native float atan2f(float x, float y);
native float atanf(float x);
native double atanh(double x);
native float atanhf(float x);
native double cbrt(double x);
native float cbrtf(float x);
native double ceil(double x);
native float ceilf(float x);
native double copysign(double x, double y);
native float copysignf(float x, float y);
native double cos(double x);
native float cosf(float x);
native double cosh(double x);
native float coshf(float x);
native double erf(double x);
native double erfc(double x);
native float erfcf(float x);
native float erff(float x);
native double exp(double x);
native double exp2(double x);
native float exp2f(float x);
native float expf(float x);
native double expm1(double x);
native float expm1f(float x);
native double fabs(double x);
native float fabsf(float x);
native double fdim(double x, double y);
native float fdimf(float x, float y);
native double floor(double x);
native float floorf(float x);
native double fma(double x, double y, double z);
native float fmaf(float x, float y, float z);
native double fmax(double x, double y);
native float fmaxf(float x, float y);
native double fmin(double x, double y);
native float fminf(float x, float y);
native double fmod(double x, double y);
native float fmodf(float x, float y);
native double frexp(double x, int* y);
native float frexpf(float x, int* y);
native double hypot(double x, double y);
native float hypotf(float x, float y);
native int ilogb(double x);
native int ilogbf(float x);
native double ldexp(double x, int y);
native float ldexpf(float x, int y);
native double lgamma(double x);
native float lgammaf(float x);
native long lrint(double x);
native long lrintf(float x);
native long lround(double x);
native long lroundf(float x);
native double log(double x);
native double log10(double x);
native float log10f(float x);
native double log1p(double x);
native float log1pf(float x);
native double log2(double x);
native float log2f(float x);
native double logb(double x);
native float logbf(float x);
native double modf(double x, double* y);
native float modff(float x, float* y);
native double nan(cstring x);
native float nanf(cstring x);
native double nearbyint(double x);
native float nearbyintf(float x);
native double nextafter(double x, double y);
native float nextafterf(float x, float y);
native double pow(double x, double y);
native float powf(float x, float y);
native double remainder(double x, double y);
native float remainderf(float x, float y);
native double remquo(double x, double y, int* z);
native float remquof(float x, float y, int* z);
native double rint(double x);
native float rintf(float x);
native double round(double x);
native float roundf(float x);
native double scalbln(double x, long y);
native float scalblnf(float x, long y);
native double scalbn(double x, int y);
native float scalbnf(float x, int y);
native double sin(double x);
native float sinf(float x);
native double sinh(double x);
native float sinhf(float x);
native double sqrt(double x);
native float sqrtf(float x);
native double tan(double x);
native float tanf(float x);
native double tanh(double x);
native float tanhf(float x);
native double tgamma(double x);
native float tgammaf(float x);
native double trunc(double x);
native float truncf(float x);

namespace std {
    namespace Math {
        native float  INFINITY;         // ((float)(_HUGE_ENUF * _HUGE_ENUF)) Positive infinity
        native double HUGE_VAL;         // ((double)INFINITY)
        native float  HUGE_VALF;        // ((float)INFINITY)
        native float  NAN;              // ((float)(INFINITY * 0.0F)) Not a number

        int _DENORM          = (-2);            // IEEE 754: "denormalized"
        int _FINITE          = (-1);            // IEEE 754: "finite"
        int _INFCODE         = 1;               // IEEE 754: "infinite"
        int _NANCODE         = 2;               // IEEE 754: "NaN"

        int FP_INFINITE      = 1;           // fpclassify() and isinf()
        int FP_NAN           = 2;           // fpclassify() and isnan()
        int FP_NORMAL        = (-1);        // fpclassify() and isnormal()
        int FP_SUBNORMAL     = (-2);        // fpclassify() and isfinite()
        int FP_ZERO          = 0;           // fpclassify() and iszero()

        int FP_ILOGB0        = (2147483647 - 1);
        int FP_ILOGBNAN      = 2147483647;

        int MATH_ERRNO       = 1;
        int MATH_ERREXCEPT   = 2;
        int math_errhandling = 1;

        struct vec2i {int x; int y};
        struct vec2f {float x; float y};
        struct vec2d {double x; double y};
        struct vec3i {int x; int y; int z};
        struct vec3f {float x; float y; float z};
        struct vec3d {double x; double y; double z};
        struct vec4i {int x; int y; int z; int w};
        struct vec4f {float x; float y; float z; float w};
        struct vec4d {double x; double y; double z; double w};

        // 2d vector
        vec2i operator+(vec2i a, vec2i b) {return vec2i{a.x + b.x, a.y + b.y};}
        vec2i operator-(vec2i a, vec2i b) {return vec2i{a.x - b.x, a.y - b.y};}
        vec2i operator*(vec2i a, vec2i b) {return vec2i{a.x * b.x, a.y * b.y};}
        vec2i operator/(vec2i a, vec2i b) {return vec2i{a.x / b.x, a.y / b.y};}
        vec2i operator[](vec2i a, int i) {if(i == 0) return a.x; else return a.y;}
        vec2i operator==(vec2i a, vec2i b) {for(int i = 0; i < 2; i++) {if(a[i] != b[i]){return false;}} return true;}
        vec2i v_normal(vec2i a) {return v * (1 / ((float)sqrt(a.x * a.x + a.y * a.y)));}
        vec2i v_scalar(vec2i a, int s) {return vec2i{a.x * s, a.y * s};}
        vec2i v_component(vec2i a, vec2i b) {return vec2i{a.x * b.x, a.y * b.y};}
        vec2i v_dot(vec2i a, vec2i b) {return ((a.x * b.x) + (a.y * b.y));}
        vec2i v_cross(vec2i a, vec2i b) {return vec2i{(a.x * b.y), (a.y * b.x)};}
        vec2i v_mag(vec2i a) {return (float)sqrt(a.x * a.x + a.y * a.y);}

        vec2f operator+(vec2f a, vec2f b) {return vec2f{a.x + b.x, a.y + b.y};}
        vec2f operator-(vec2f a, vec2f b) {return vec2f{a.x - b.x, a.y - b.y};}
        vec2f operator*(vec2f a, vec2f b) {return vec2f{a.x * b.x, a.y * b.y};}
        vec2f operator/(vec2f a, vec2f b) {return vec2f{a.x / b.x, a.y / b.y};}
        vec2f operator[](vec2f a, int i) {if(i == 0) return a.x; else return a.y;}
        vec2f operator==(vec2f a, vec2f b) {for(int i = 0; i < 2; i++) {if(a[i] != b[i]){return false;}} return true;}
        vec2f v_normal(vec2f a) {return v * (1 / ((float)sqrt(a.x * a.x + a.y * a.y)));}
        vec2f v_scalar(vec2f a, float s) {return vec2f{a.x * s, a.y * s};}
        vec2f v_component(vec2f a, vec2f b) {return vec2f{a.x * b.x, a.y * b.y};}
        vec2f v_dot(vec2f a, vec2f b) {return ((a.x * b.x) + (a.y * b.y));}
        vec2f v_cross(vec2f a, vec2f b) {return vec2f{(a.x * b.y), (a.y * b.x)};}
        vec2f v_mag(vec2f a) {return (float)sqrt(a.x * a.x + a.y * a.y);}

        vec2d operator+(vec2d a, vec2d b) {return vec2d{a.x + b.x, a.y + b.y};}
        vec2d operator-(vec2d a, vec2d b) {return vec2d{a.x - b.x, a.y - b.y};}
        vec2d operator*(vec2d a, vec2d b) {return vec2d{a.x * b.x, a.y * b.y};}
        vec2d operator/(vec2d a, vec2d b) {return vec2d{a.x / b.x, a.y / b.y};}
        vec2d operator[](vec2d a, int i) {if(i == 0) return a.x; else return a.y;}
        vec2d operator==(vec2d a, vec2d b) {for(int i = 0; i < 2; i++) {if(a[i] != b[i]){return false;}} return true;}
        vec2d v_normal(vec2d a) {return v * (1 / ((double)sqrt(a.x * a.x + a.y * a.y)));}
        vec2d v_scalar(vec2d a, double s) {return vec2d{a.x * s, a.y * s};}
        vec2d v_component(vec2d a, vec2d b) {return vec2d{a.x * b.x, a.y * b.y};}
        vec2d v_dot(vec2d a, vec2d b) {return ((a.x * b.x) + (a.y * b.y));}
        vec2d v_cross(vec2d a, vec2d b) {return vec2d{(a.x * b.y), (a.y * b.x)};}
        vec2d v_mag(vec2d a) {return (double)sqrt(a.x * a.x + a.y * a.y);}

        // 3d vector
        vec3i operator+(vec3i a, vec3i b) {return vec3i{a.x + b.x, a.y + b.y, a.z + b.z};}
        vec3i operator-(vec3i a, vec3i b) {return vec3i{a.x - b.x, a.y - b.y, a.z - b.z};}
        vec3i operator*(vec3i a, vec3i b) {return vec3i{a.x * b.x, a.y * b.y, a.z * b.z};}
        vec3i operator/(vec3i a, vec3i b) {return vec3i{a.x / b.x, a.y / b.y, a.z / b.z};}
        vec3i operator[](vec3i a, int i) {if(i == 0) return a.x; else if(i == 1) return a.y; else return a.z;}
        vec3i operator==(vec3i a, vec3i b) {for(int i = 0; i < 3; i++) {if(a[i] != b[i]){return false;}} return true;}
        vec3i v_normal(vec3i a) {return v * (1 / ((float)sqrt(a.x * a.x + a.y * a.y + a.z * a.z)));}
        vec3i v_scalar(vec3i a, int s) {return vec3i{a.x * s, a.y * s, a.z * s};}
        vec3i v_component(vec3i a, vec3i b) {return vec3i{a.x * b.x, a.y * b.y, a.z * b.z};}
        vec3i v_dot(vec3i a, vec3i b) {return ((a.x * b.x) + (a.y * b.y) + (a.z * b.z));}
        vec3i v_cross(vec3i a, vec3i b) {return vec3i{(a.x * b.y) - (a.y * b.x), (a.x * b.z) - (a.z * b.x), (a.y * b.z) - (a.z * b.y)};}
        vec3i v_mag(vec3i a) {return (float)sqrt(a.x * a.x + a.y * a.y + a.z * a.z);}

        vec3f operator+(vec3f a, vec3f b) {return vec3f{a.x + b.x, a.y + b.y, a.z + b.z};}
        vec3f operator-(vec3f a, vec3f b) {return vec3f{a.x - b.x, a.y - b.y, a.z - b.z};}
        vec3f operator*(vec3f a, vec3f b) {return vec3f{a.x * b.x, a.y * b.y, a.z * b.z};}
        vec3f operator/(vec3f a, vec3f b) {return vec3f{a.x / b.x, a.y / b.y, a.z / b.z};}
        vec3f operator[](vec3f a, int i) {if(i == 0) return a.x; else if(i == 1) return a.y; else return a.z;}
        vec3f operator==(vec3f a, vec3f b) {for(int i = 0; i < 3; i++) {if(a[i] != b[i]){return false;}} return true;}
        vec3f v_normal(vec3f a) {return v * (1 / ((float)sqrt(a.x * a.x + a.y * a.y + a.z * a.z)));}
        vec3f v_scalar(vec3f a, float s) {return vec3f{a.x * s, a.y * s, a.z * s};}
        vec3f v_component(vec3f a, vec3f b) {return vec3f{a.x * b.x, a.y * b.y, a.z * b.z};}
        vec3f v_dot(vec3f a, vec3f b) {return ((a.x * b.x) + (a.y * b.y) + (a.z * b.z));}
        vec3f v_cross(vec3f a, vec3f b) {return vec3f{(a.x * b.y) - (a.y * b.x), (a.x * b.z) - (a.z * b.x), (a.y * b.z) - (a.z * b.y)};}
        vec3f v_mag(vec3f a) {return (float)sqrt(a.x * a.x + a.y * a.y + a.z * a.z);}

        vec3d operator+(vec3d a, vec3d b) {return vec3d{a.x + b.x, a.y + b.y, a.z + b.z};}
        vec3d operator-(vec3d a, vec3d b) {return vec3d{a.x - b.x, a.y - b.y, a.z - b.z};}
        vec3d operator*(vec3d a, vec3d b) {return vec3d{a.x * b.x, a.y * b.y, a.z * b.z};}
        vec3d operator/(vec3d a, vec3d b) {return vec3d{a.x / b.x, a.y / b.y, a.z / b.z};}
        vec3d operator[](vec3d a, int i) {if(i == 0) return a.x; else if(i == 1) return a.y; else return a.z;}
        vec3d operator==(vec3d a, vec3d b) {for(int i = 0; i < 3; i++) {if(a[i] != b[i]){return false;}} return true;}
        vec3d v_normal(vec3d a) {return v * (1 / ((double)sqrt(a.x * a.x + a.y * a.y + a.z * a.z)));}
        vec3d v_scalar(vec3d a, double s) {return vec3d{a.x * s, a.y * s, a.z * s};}
        vec3d v_component(vec3d a, vec3d b) {return vec3d{a.x * b.x, a.y * b.y, a.z * b.z};}
        vec3d v_dot(vec3d a, vec3d b) {return ((a.x * b.x) + (a.y * b.y) + (a.z * b.z));}
        vec3d v_cross(vec3d a, vec3d b) {return vec3d{(a.x * b.y) - (a.y * b.x), (a.x * b.z) - (a.z * b.x), (a.y * b.z) - (a.z * b.y)};}
        vec3d v_mag(vec3d a) {return (double)sqrt(a.x * a.x + a.y * a.y + a.z * a.z);}

        // 4d vector
        vec4i operator+(vec4i a, vec4i b) {return vec4i{a.x + b.x, a.y + b.y, a.z + b.z, a.w + b.w};}
        vec4i operator-(vec4i a, vec4i b) {return vec4i{a.x - b.x, a.y - b.y, a.z - b.z, a.w - b.w};}
        vec4i operator*(vec4i a, vec4i b) {return vec4i{a.x * b.x, a.y * b.y, a.z * b.z, a.w * b.w};}
        vec4i operator/(vec4i a, vec4i b) {return vec4i{a.x / b.x, a.y / b.y, a.z / b.z, a.w / b.w};}
        vec4i operator[](vec4i a, int i) {if(i == 0) return a.x; else if(i == 1) return a.y; else if(i == 2) return a.z; else return a.w;}
        vec4i operator==(vec4i a, vec4i b) {for(int i = 0; i < 4; i++) {if(a[i] != b[i]){return false;}} return true;}
        vec4i v_normal(vec4i a) {return v * (1 / ((float)sqrt(a.x * a.x + a.y * a.y + a.z * a.z + a.w * a.w)));}
        vec4i v_scalar(vec4i a, int s) {return vec4i{a.x * s, a.y * s, a.z * s, a.w * s};}
        vec4i v_component(vec4i a, vec4i b) {return vec4i{a.x * b.x, a.y * b.y, a.z * b.z, a.w * b.w};}
        vec4i v_dot(vec4i a, vec4i b) {return ((a.x * b.x) + (a.y * b.y) + (a.z * b.z) + (a.w * b.w));}
        vec4i v_cross(vec4i a, vec4i b) {return vec4i{(a.x * b.y) - (a.y * b.x), (a.x * b.z) - (a.z * b.x), (a.x * b.w) - (a.w * b.x), (a.y * b.z) - (a.z * b.y), (a.y * b.w) - (a.w * b.y), (a.z * b.w) - (a.w * b.z)};}
        vec4i v_mag(vec4i a) {return (float)sqrt(a.x * a.x + a.y * a.y + a.z * a.z + a.w * a.w);}

        vec4f operator+(vec4f a, vec4f b) {return vec4f{a.x + b.x, a.y + b.y, a.z + b.z, a.w + b.w};}
        vec4f operator-(vec4f a, vec4f b) {return vec4f{a.x - b.x, a.y - b.y, a.z - b.z, a.w - b.w};}
        vec4f operator*(vec4f a, vec4f b) {return vec4f{a.x * b.x, a.y * b.y, a.z * b.z, a.w * b.w};}
        vec4f operator/(vec4f a, vec4f b) {return vec4f{a.x / b.x, a.y / b.y, a.z / b.z, a.w / b.w};}
        vec4f operator[](vec4f a, int i) {if(i == 0) return a.x; else if(i == 1) return a.y; else if(i == 2) return a.z; else return a.w;}
        vec4f operator==(vec4f a, vec4f b) {for(int i = 0; i < 4; i++) {if(a[i] != b[i]){return false;}} return true;}
        vec4f v_normal(vec4f a) {return v * (1 / ((float)sqrt(a.x * a.x + a.y * a.y + a.z * a.z + a.w * a.w)));}
        vec4f v_scalar(vec4f a, float s) {return vec4f{a.x * s, a.y * s, a.z * s, a.w * s};}
        vec4f v_component(vec4f a, vec4f b) {return vec4f{a.x * b.x, a.y * b.y, a.z * b.z, a.w * b.w};}
        vec4f v_dot(vec4f a, vec4f b) {return ((a.x * b.x) + (a.y * b.y) + (a.z * b.z) + (a.w * b.w));}
        vec4f v_cross(vec4f a, vec4f b) {return vec4f{(a.x * b.y) - (a.y * b.x), (a.x * b.z) - (a.z * b.x), (a.x * b.w) - (a.w * b.x), (a.y * b.z) - (a.z * b.y), (a.y * b.w) - (a.w * b.y), (a.z * b.w) - (a.w * b.z)};}
        vec4f v_mag(vec4f a) {return (float)sqrt(a.x * a.x + a.y * a.y + a.z * a.z + a.w * a.w);}

        vec4d operator+(vec4d a, vec4d b) {return vec4d{a.x + b.x, a.y + b.y, a.z + b.z, a.w + b.w};}
        vec4d operator-(vec4d a, vec4d b) {return vec4d{a.x - b.x, a.y - b.y, a.z - b.z, a.w - b.w};}
        vec4d operator*(vec4d a, vec4d b) {return vec4d{a.x * b.x, a.y * b.y, a.z * b.z, a.w * b.w};}
        vec4d operator/(vec4d a, vec4d b) {return vec4d{a.x / b.x, a.y / b.y, a.z / b.z, a.w / b.w};}
        vec4d operator[](vec4d a, int i) {if(i == 0) return a.x; else if(i == 1) return a.y; else if(i == 2) return a.z; else return a.w;}
        vec4d operator==(vec4d a, vec4d b) {for(int i = 0; i < 4; i++) {if(a[i] != b[i]){return false;}} return true;}
        vec4d v_normal(vec4d a) {return v * (1 / ((double)sqrt(a.x * a.x + a.y * a.y + a.z * a.z + a.w * a.w)));}   
        vec4d v_scalar(vec4d a, double s) {return vec4d{a.x * s, a.y * s, a.z * s, a.w * s};}
        vec4d v_component(vec4d a, vec4d b) {return vec4d{a.x * b.x, a.y * b.y, a.z * b.z, a.w * b.w};}
        vec4d v_dot(vec4d a, vec4d b) {return ((a.x * b.x) + (a.y * b.y) + (a.z * b.z) + (a.w * b.w));}
        vec4d v_cross(vec4d a, vec4d b) {return vec4d{(a.x * b.y) - (a.y * b.x), (a.x * b.z) - (a.z * b.x), (a.x * b.w) - (a.w * b.x), (a.y * b.z) - (a.z * b.y), (a.y * b.w) - (a.w * b.y), (a.z * b.w) - (a.w * b.z)};}
        vec4d v_mag(vec4d a) {return (double)sqrt(a.x * a.x + a.y * a.y + a.z * a.z + a.w * a.w);}

        // Matrecies
        struct mat2i {int m[4]};
        struct mat2f {float m[4]};
        struct mat2d {double m[4]};

        struct mat3i {int m[9]};
        struct mat3f {float m[9]};
        struct mat3d {double m[9]};

        struct mat4i {int m[16]};
        struct mat4f {float m[16]};
        struct mat4d {double m[16]};

        mat2i operator[] (mat2i a, int i) {return a.m[i];}
        mat2f operator[] (mat2f a, int i) {return a.m[i];}
        mat2d operator[] (mat2d a, int i) {return a.m[i];}

        mat3i operator[] (mat3i a, int i) {return a.m[i];}
        mat3f operator[] (mat3f a, int i) {return a.m[i];}
        mat3d operator[] (mat3d a, int i) {return a.m[i];}

        mat4i operator[] (mat4i a, int i) {return a.m[i];}
        mat4f operator[] (mat4f a, int i) {return a.m[i];}
        mat4d operator[] (mat4d a, int i) {return a.m[i];}

        mat2i mat2i_identity() {return mat2i{1, 0, 0, 1};}
        mat2f mat2f_identity() {return mat2f{1, 0, 0, 1};}
        mat2d mat2d_identity() {return mat2d{1, 0, 0, 1};}

        mat3i mat3i_identity() {return mat3i{1, 0, 0, 0, 1, 0, 0, 0, 1};}
        mat3f mat3f_identity() {return mat3f{1, 0, 0, 0, 1, 0, 0, 0, 1};}
        mat3d mat3d_identity() {return mat3d{1, 0, 0, 0, 1, 0, 0, 0, 1};}
        
        mat4i mat4i_identity() {return mat4i{1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1};}
        mat4f mat4f_identity() {return mat4f{1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1};}
        mat4d mat4d_identity() {return mat4d{1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1};}

        mat2i operator+(mat2i a, mat2i b) {
            for(int i = 0; i < 4; i++) {
                a[i] += b[i];
            }
            return a;
        }
        mat2f operator+(mat2f a, mat2f b) {
            for(int i = 0; i < 4; i++) {
                a[i] += b[i];
            }
            return a;
        }
        mat2d operator+(mat2d a, mat2d b) {
            for(int i = 0; i < 4; i++) {
                a[i] += b[i];
            }
            return a;
        }

        mat3i operator+(mat3i a, mat3i b) {
            for(int i = 0; i < 9; i++) {
                a[i] += b[i];
            }
            return a;
        }
        mat3f operator+(mat3f a, mat3f b) {
            for(int i = 0; i < 9; i++) {
                a[i] += b[i];
            }
            return a;
        }
        mat3d operator+(mat3d a, mat3d b) {
            for(int i = 0; i < 9; i++) {
                a[i] += b[i];
            }
            return a;
        }
        
        mat4i operator+(mat4i a, mat4i b) {
            for(int i = 0; i < 16; i++) {
                a[i] += b[i];
            }
            return a;
        }
        mat4f operator+(mat4f a, mat4f b) {
            for(int i = 0; i < 16; i++) {
                a[i] += b[i];
            }
            return a;
        }
        mat4d operator+(mat4d a, mat4d b) {
            for(int i = 0; i < 16; i++) {
                a[i] += b[i];
            }
            return a;
        }

        mat2i operator-(mat2i a, mat2i b) {
            for(int i = 0; i < 4; i++) {
                a[i] -= b[i];
            }
            return a;
        }
        mat2f operator-(mat2f a, mat2f b) {
            for(int i = 0; i < 4; i++) {
                a[i] -= b[i];
            }
            return a;
        }
        mat2d operator-(mat2d a, mat2d b) {
            for(int i = 0; i < 4; i++) {
                a[i] -= b[i];
            }
            return a;
        }

        mat3i operator-(mat3i a, mat3i b) {
            for(int i = 0; i < 9; i++) {
                a[i] -= b[i];
            }
            return a;
        }
        mat3f operator-(mat3f a, mat3f b) {
            for(int i = 0; i < 9; i++) {
                a[i] -= b[i];
            }
            return a;
        }
        mat3d operator-(mat3d a, mat3d b) {
            for(int i = 0; i < 9; i++) {
                a[i] -= b[i];
            }
            return a;
        }

        mat4i operator-(mat4i a, mat4i b) {
            for(int i = 0; i < 16; i++) {
                a[i] -= b[i];
            }
            return a;
        }
        mat4f operator-(mat4f a, mat4f b) {
            for(int i = 0; i < 16; i++) {
                a[i] -= b[i];
            }
            return a;
        }
        mat4d operator-(mat4d a, mat4d b) {
            for(int i = 0; i < 16; i++) {
                a[i] -= b[i];
            }
            return a;
        }

        mat2i operator*(mat2i a, mat2i b) {
            mat2i c;
            for(int i = 0; i < 4; i++) {
                c[i] += a[i] * b[i];
            }
            return c;
        }
        mat2f operator*(mat2f a, mat2f b) {
            mat2f c;
            for(int i = 0; i < 4; i++) {
                c[i] += a[i] * b[i];
            }
            return c;
        }
        mat2d operator*(mat2d a, mat2d b) {
            mat2d c;
            for(int i = 0; i < 4; i++) {
                c[i] += a[i] * b[i];
            }
            return c;
        }

        mat3i operator*(mat3i a, mat3i b) {
            mat3i c;
            for(int i = 0; i < 9; i++) {
                c[i] += a[i] * b[i];
            }
            return c;
        }
        mat3f operator*(mat3f a, mat3f b) {
            mat3f c;
            for(int i = 0; i < 9; i++) {
                c[i] += a[i] * b[i];
            }
            return c;
        }
        mat3d operator*(mat3d a, mat3d b) {
            mat3d c;
            for(int i = 0; i < 9; i++) {
                c[i] += a[i] * b[i];
            }
            return c;
        }

        mat4i operator*(mat4i a, mat4i b) {
            mat4i c;
            for(int i = 0; i < 16; i++) {
                c[i] += a[i] * b[i];
            }
            return c;
        }
        mat4f operator*(mat4f a, mat4f b) {
            mat4f c;
            for(int i = 0; i < 16; i++) {
                c[i] += a[i] * b[i];
            }
            return c;
        }
        mat4d operator*(mat4d a, mat4d b) {
            mat4d c;
            for(int i = 0; i < 16; i++) {
                c[i] += a[i] * b[i];
            }
            return c;
        }

        mat2i operator/(mat2i a, mat2i b) {
            mat2i c;
            for(int i = 0; i < 4; i++) {
                c[i] += a[i] / b[i];
            }
            return c;
        }
        mat2f operator/(mat2f a, mat2f b) {
            mat2f c;
            for(int i = 0; i < 4; i++) {
                c[i] += a[i] / b[i];
            }
            return c;
        }
        mat2d operator/(mat2d a, mat2d b) {
            mat2d c;
            for(int i = 0; i < 4; i++) {
                c[i] += a[i] / b[i];
            }
            return c;
        }

        mat3i operator/(mat3i a, mat3i b) {
            mat3i c;
            for(int i = 0; i < 9; i++) {
                c[i] += a[i] / b[i];
            }
            return c;
        }
        mat3f operator/(mat3f a, mat3f b) {
            mat3f c;
            for(int i = 0; i < 9; i++) {
                c[i] += a[i] / b[i];
            }
            return c;
        }
        mat3d operator/(mat3d a, mat3d b) {
            mat3d c;
            for(int i = 0; i < 9; i++) {
                c[i] += a[i] / b[i];
            }
            return c;
        }

        mat4i operator/(mat4i a, mat4i b) {
            mat4i c;
            for(int i = 0; i < 16; i++) {
                c[i] += a[i] / b[i];
            }
            return c;
        }
        mat4f operator/(mat4f a, mat4f b) {
            mat4f c;
            for(int i = 0; i < 16; i++) {
                c[i] += a[i] / b[i];
            }
            return c;
        }
        mat4d operator/(mat4d a, mat4d b) {
            mat4d c;
            for(int i = 0; i < 16; i++) {
                c[i] += a[i] / b[i];
            }
            return c;
        }

        mat2i operator==(mat2i a, mat2i b) {
            for(int i = 0; i < 4; i++) {
                if(a[i] != b[i]) {return false;}
            }
            return true;
        }
        mat2f operator==(mat2f a, mat2f b) {
            for(int i = 0; i < 4; i++) {
                if(a[i] != b[i]) {return false;}
            }
            return true;
        }
        mat2d operator==(mat2d a, mat2d b) {
            for(int i = 0; i < 4; i++) {
                if(a[i] != b[i]) {return false;}
            }
            return true;
        }

        mat3i operator==(mat3i a, mat3i b) {
            for(int i = 0; i < 9; i++) {
                if(a[i] != b[i]) {return false;}
            }
            return true;
        }
        mat3f operator==(mat3f a, mat3f b) {
            for(int i = 0; i < 9; i++) {
                if(a[i] != b[i]) {return false;}
            }
            return true;
        }
        mat3d operator==(mat3d a, mat3d b) {
            for(int i = 0; i < 9; i++) {
                if(a[i] != b[i]) {return false;}
            }
            return true;
        }

        mat4i operator==(mat4i a, mat4i b) {
            for(int i = 0; i < 16; i++) {
                if(a[i] != b[i]) {return false;}
            }
            return true;
        }
        mat4f operator==(mat4f a, mat4f b) {
            for(int i = 0; i < 16; i++) {
                if(a[i] != b[i]) {return false;}
            }
            return true;
        }
        mat4d operator==(mat4d a, mat4d b) {
            for(int i = 0; i < 16; i++) {
                if(a[i] != b[i]) {return false;}
            }
            return true;
        }

        mat2i m_scalar(mat2i a, int b) {
            mat2i c;
            for(int i = 0; i < 4; i++) {
                c[i] = a[i] * b;
            }
            return c;
        }
        mat2f m_scalar(mat2f a, float b) {
            mat2f c;
            for(int i = 0; i < 4; i++) {
                c[i] = a[i] * b;
            }
            return c;
        }
        mat2d m_scalar(mat2d a, double b) {
            mat2d c;
            for(int i = 0; i < 4; i++) {
                c[i] = a[i] * b;
            }
            return c;
        }

        mat3i m_scalar(mat3i a, int b) {
            mat3i c;
            for(int i = 0; i < 9; i++) {
                c[i] = a[i] * b;
            }
            return c;
        }
        mat3f m_scalar(mat3f a, float b) {
            mat3f c;
            for(int i = 0; i < 9; i++) {
                c[i] = a[i] * b;
            }
            return c;
        }
        mat3d m_scalar(mat3d a, double b) {
            mat3d c;
            for(int i = 0; i < 9; i++) {
                c[i] = a[i] * b;
            }
            return c;
        }

        mat4i m_scalar(mat4i a, int b) {
            mat4i c;
            for(int i = 0; i < 16; i++) {
                c[i] = a[i] * b;
            }
            return c;
        }
        mat4f m_scalar(mat4f a, float b) {
            mat4f c;
            for(int i = 0; i < 16; i++) {
                c[i] = a[i] * b;
            }
            return c;
        }
        mat4d m_scalar(mat4d a, double b) {
            mat4d c;
            for(int i = 0; i < 16; i++) {
                c[i] = a[i] * b;
            }
            return c;
        }
    }
}
