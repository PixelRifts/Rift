cinclude "math.h";
import "io.rf";

/*
    Functions
    @author: Mr. Hecker (Stolen from the C standard library)
*/
native double acos(double x);
native float acosf(float x);
native double acosh(double x);
native float acoshf(float x);
native double asin(double x);
native float asinf(float x);
native double asinh(double x);
native float asinhf(float x);
native double atan(double x);
native double atan2(double x, double y);
native float atan2f(float x, float y);
native float atanf(float x);
native double atanh(double x);
native float atanhf(float x);
native double cbrt(double x);
native float cbrtf(float x);
native double ceil(double x);
native float ceilf(float x);
native double copysign(double x, double y);
native float copysignf(float x, float y);
native double cos(double x);
native float cosf(float x);
native double cosh(double x);
native float coshf(float x);
native double erf(double x);
native double erfc(double x);
native float erfcf(float x);
native float erff(float x);
native double exp(double x);
native double exp2(double x);
native float exp2f(float x);
native float expf(float x);
native double expm1(double x);
native float expm1f(float x);
native double fabs(double x);
native float fabsf(float x);
native double fdim(double x, double y);
native float fdimf(float x, float y);
native double floor(double x);
native float floorf(float x);
native double fma(double x, double y, double z);
native float fmaf(float x, float y, float z);
native double fmax(double x, double y);
native float fmaxf(float x, float y);
native double fmin(double x, double y);
native float fminf(float x, float y);
native double fmod(double x, double y);
native float fmodf(float x, float y);
native double frexp(double x, int* y);
native float frexpf(float x, int* y);
native double hypot(double x, double y);
native float hypotf(float x, float y);
native int ilogb(double x);
native int ilogbf(float x);
native double ldexp(double x, int y);
native float ldexpf(float x, int y);
native double lgamma(double x);
native float lgammaf(float x);
native long lrint(double x);
native long lrintf(float x);
native long lround(double x);
native long lroundf(float x);
native double log(double x);
native double log10(double x);
native float log10f(float x);
native double log1p(double x);
native float log1pf(float x);
native double log2(double x);
native float log2f(float x);
native double logb(double x);
native float logbf(float x);
native double modf(double x, double* y);
native float modff(float x, float* y);
native double nan(cstring x);
native float nanf(cstring x);
native double nearbyint(double x);
native float nearbyintf(float x);
native double nextafter(double x, double y);
native float nextafterf(float x, float y);
native double pow(double x, double y);
native float powf(float x, float y);
native double remainder(double x, double y);
native float remainderf(float x, float y);
native double remquo(double x, double y, int* z);
native float remquof(float x, float y, int* z);
native double rint(double x);
native float rintf(float x);
native double round(double x);
native float roundf(float x);
native double scalbln(double x, long y);
native float scalblnf(float x, long y);
native double scalbn(double x, int y);
native float scalbnf(float x, int y);
native double sin(double x);
native float sinf(float x);
native double sinh(double x);
native float sinhf(float x);
native double sqrt(double x);
native float sqrtf(float x);
native double tan(double x);
native float tanf(float x);
native double tanh(double x);
native float tanhf(float x);
native double tgamma(double x);
native float tgammaf(float x);
native double trunc(double x);
native float truncf(float x);

namespace std {
    namespace Math {
        native float  INFINITY;         // ((float)(_HUGE_ENUF * _HUGE_ENUF)) Positive infinity
        native double HUGE_VAL;         // ((double)INFINITY)
        native float  HUGE_VALF;        // ((float)INFINITY)
        native float  NAN;              // ((float)(INFINITY * 0.0F)) Not a number
        
        int _DENORM          = (-2);            // IEEE 754: "denormalized"
        int _FINITE          = (-1);            // IEEE 754: "finite"
        int _INFCODE         = 1;               // IEEE 754: "infinite"
        int _NANCODE         = 2;               // IEEE 754: "NaN"
        
        int FP_INFINITE      = 1;           // fpclassify() and isinf()
        int FP_NAN           = 2;           // fpclassify() and isnan()
        int FP_NORMAL        = (-1);        // fpclassify() and isnormal()
        int FP_SUBNORMAL     = (-2);        // fpclassify() and isfinite()
        int FP_ZERO          = 0;           // fpclassify() and iszero()
        
        int FP_ILOGB0        = (2147483647 - 1);
        int FP_ILOGBNAN      = 2147483647;
        
        int MATH_ERRNO       = 1;
        int MATH_ERREXCEPT   = 2;
        int math_errhandling = 1;

        struct vec2i {int x; int y;}
        struct vec2f {float x; float y;}
        struct vec2d {double x; double y;}

        struct vec3i {int x; int y; int z;}
        struct vec3f {float x; float y; float z;}
        struct vec3d {double x; double y; double z;}

        struct vec4i {int x; int y; int z; int w;}
        struct vec4f {float x; float y; float z; float w;}
        struct vec4d {double x; double y; double z; double w;}

        struct mat2i {int[4] m;}
        struct mat2f {float[4] m;}
        struct mat2d {double[4] m;}

        struct mat3i {int[9] m;}
        struct mat3f {float[9] m;}
        struct mat3d {double[9] m;}

        struct mat4i {int[16] m;}
        struct mat4f {float[16] m;}
        struct mat4d {double[16] m;}

        vec2i operator+(vec2i a, vec2i b) {return (vec2i) { .x = (a.x + b.x), .y = (a.y + b.y)};}
        vec2f operator+(vec2f a, vec2f b) {return (vec2f) { .x = (a.x + b.x), .y = (a.y + b.y)};}
        vec2d operator+(vec2d a, vec2d b) {return (vec2d) { .x = (a.x + b.x), .y = (a.y + b.y)};}

        vec2i operator-(vec2i a, vec2i b) {return (vec2i) { .x = (a.x - b.x), .y = (a.y - b.y)};}
        vec2f operator-(vec2f a, vec2f b) {return (vec2f) { .x = (a.x - b.x), .y = (a.y - b.y)};}
        vec2d operator-(vec2d a, vec2d b) {return (vec2d) { .x = (a.x - b.x), .y = (a.y - b.y)};}

        vec2i operator*(vec2i a, vec2i b) {return (vec2i) { .x = (a.x * b.x), .y = (a.y * b.y)};}
        vec2f operator*(vec2f a, vec2f b) {return (vec2f) { .x = (a.x * b.x), .y = (a.y * b.y)};}
        vec2d operator*(vec2d a, vec2d b) {return (vec2d) { .x = (a.x * b.x), .y = (a.y * b.y)};}

        vec2i operator/(vec2i a, vec2i b) {return (vec2i) { .x = (a.x / b.x), .y = (a.y / b.y)};}
        vec2f operator/(vec2f a, vec2f b) {return (vec2f) { .x = (a.x / b.x), .y = (a.y / b.y)};}
        vec2d operator/(vec2d a, vec2d b) {return (vec2d) { .x = (a.x / b.x), .y = (a.y / b.y)};}

        vec3i operator+(vec3i a, vec3i b) {return (vec3i) { .x = (a.x + b.x), .y = (a.y + b.y), .z = (a.z + b.z)};}
        vec3f operator+(vec3f a, vec3f b) {return (vec3f) { .x = (a.x + b.x), .y = (a.y + b.y), .z = (a.z + b.z)};}
        vec3d operator+(vec3d a, vec3d b) {return (vec3d) { .x = (a.x + b.x), .y = (a.y + b.y), .z = (a.z + b.z)};}

        vec3i operator-(vec3i a, vec3i b) {return (vec3i) { .x = (a.x - b.x), .y = (a.y - b.y), .z = (a.z - b.z)};}
        vec3f operator-(vec3f a, vec3f b) {return (vec3f) { .x = (a.x - b.x), .y = (a.y - b.y), .z = (a.z - b.z)};}
        vec3d operator-(vec3d a, vec3d b) {return (vec3d) { .x = (a.x - b.x), .y = (a.y - b.y), .z = (a.z - b.z)};}

        vec3i operator*(vec3i a, vec3i b) {return (vec3i) { .x = (a.x * b.x), .y = (a.y * b.y), .z = (a.z * b.z)};}
        vec3f operator*(vec3f a, vec3f b) {return (vec3f) { .x = (a.x * b.x), .y = (a.y * b.y), .z = (a.z * b.z)};}
        vec3d operator*(vec3d a, vec3d b) {return (vec3d) { .x = (a.x * b.x), .y = (a.y * b.y), .z = (a.z * b.z)};}

        vec3i operator/(vec3i a, vec3i b) {return (vec3i) { .x = (a.x / b.x), .y = (a.y / b.y), .z = (a.z / b.z)};}
        vec3f operator/(vec3f a, vec3f b) {return (vec3f) { .x = (a.x / b.x), .y = (a.y / b.y), .z = (a.z / b.z)};}
        vec3d operator/(vec3d a, vec3d b) {return (vec3d) { .x = (a.x / b.x), .y = (a.y / b.y), .z = (a.z / b.z)};}

        vec4i operator+(vec4i a, vec4i b) {return (vec4i) { .x = (a.x + b.x), .y = (a.y + b.y), .z = (a.z + b.z), .w = (a.w + b.w)};}
        vec4f operator+(vec4f a, vec4f b) {return (vec4f) { .x = (a.x + b.x), .y = (a.y + b.y), .z = (a.z + b.z), .w = (a.w + b.w)};}
        vec4d operator+(vec4d a, vec4d b) {return (vec4d) { .x = (a.x + b.x), .y = (a.y + b.y), .z = (a.z + b.z), .w = (a.w + b.w)};}

        vec4i operator-(vec4i a, vec4i b) {return (vec4i) { .x = (a.x - b.x), .y = (a.y - b.y), .z = (a.z - b.z), .w = (a.w - b.w)};}
        vec4f operator-(vec4f a, vec4f b) {return (vec4f) { .x = (a.x - b.x), .y = (a.y - b.y), .z = (a.z - b.z), .w = (a.w - b.w)};}
        vec4d operator-(vec4d a, vec4d b) {return (vec4d) { .x = (a.x - b.x), .y = (a.y - b.y), .z = (a.z - b.z), .w = (a.w - b.w)};}

        vec4i operator*(vec4i a, vec4i b) {return (vec4i) { .x = (a.x * b.x), .y = (a.y * b.y), .z = (a.z * b.z), .w = (a.w * b.w)};}
        vec4f operator*(vec4f a, vec4f b) {return (vec4f) { .x = (a.x * b.x), .y = (a.y * b.y), .z = (a.z * b.z), .w = (a.w * b.w)};}
        vec4d operator*(vec4d a, vec4d b) {return (vec4d) { .x = (a.x * b.x), .y = (a.y * b.y), .z = (a.z * b.z), .w = (a.w * b.w)};}

        vec4i operator/(vec4i a, vec4i b) {return (vec4i) { .x = (a.x / b.x), .y = (a.y / b.y), .z = (a.z / b.z), .w = (a.w / b.w)};}
        vec4f operator/(vec4f a, vec4f b) {return (vec4f) { .x = (a.x / b.x), .y = (a.y / b.y), .z = (a.z / b.z), .w = (a.w / b.w)};}
        vec4d operator/(vec4d a, vec4d b) {return (vec4d) { .x = (a.x / b.x), .y = (a.y / b.y), .z = (a.z / b.z), .w = (a.w / b.w)};}

        bool operator==(vec2i a, vec2i b) {return (a.x == b.x) && (a.y == b.y);}
        bool operator==(vec2f a, vec2f b) {return (a.x == b.x) && (a.y == b.y);}
        bool operator==(vec2d a, vec2d b) {return (a.x == b.x) && (a.y == b.y);}

        bool operator==(vec3i a, vec3i b) {return (a.x == b.x) && (a.y == b.y) && (a.z == b.z);}
        bool operator==(vec3f a, vec3f b) {return (a.x == b.x) && (a.y == b.y) && (a.z == b.z);}
        bool operator==(vec3d a, vec3d b) {return (a.x == b.x) && (a.y == b.y) && (a.z == b.z);}

        bool operator==(vec4i a, vec4i b) {return (a.x == b.x) && (a.y == b.y) && (a.z == b.z) && (a.w == b.w);}
        bool operator==(vec4f a, vec4f b) {return (a.x == b.x) && (a.y == b.y) && (a.z == b.z) && (a.w == b.w);}
        bool operator==(vec4d a, vec4d b) {return (a.x == b.x) && (a.y == b.y) && (a.z == b.z) && (a.w == b.w);}

        bool operator!=(vec2i a, vec2i b) {return (a.x != b.x) || (a.y != b.y);}
        bool operator!=(vec2f a, vec2f b) {return (a.x != b.x) || (a.y != b.y);}
        bool operator!=(vec2d a, vec2d b) {return (a.x != b.x) || (a.y != b.y);}

        bool operator!=(vec3i a, vec3i b) {return (a.x != b.x) || (a.y != b.y) || (a.z != b.z);}
        bool operator!=(vec3f a, vec3f b) {return (a.x != b.x) || (a.y != b.y) || (a.z != b.z);}
        bool operator!=(vec3d a, vec3d b) {return (a.x != b.x) || (a.y != b.y) || (a.z != b.z);}

        bool operator!=(vec4i a, vec4i b) {return (a.x != b.x) || (a.y != b.y) || (a.z != b.z) || (a.w != b.w);}
        bool operator!=(vec4f a, vec4f b) {return (a.x != b.x) || (a.y != b.y) || (a.z != b.z) || (a.w != b.w);}
        bool operator!=(vec4d a, vec4d b) {return (a.x != b.x) || (a.y != b.y) || (a.z != b.z) || (a.w != b.w);}

        vec2i operator+(vec2i a, float b) {return (vec2i) { .x = (a.x + b), .y = (a.y + b)};}
        vec2f operator+(vec2f a, float b) {return (vec2f) { .x = (a.x + b), .y = (a.y + b)};}
        vec2d operator+(vec2d a, double b) {return (vec2d) { .x = (a.x + b), .y = (a.y + b)};}

        vec2i operator-(vec2i a, float b) {return (vec2i) { .x = (a.x - b), .y = (a.y - b)};}
        vec2f operator-(vec2f a, float b) {return (vec2f) { .x = (a.x - b), .y = (a.y - b)};}
        vec2d operator-(vec2d a, double b) {return (vec2d) { .x = (a.x - b), .y = (a.y - b)};}

        vec2i operator*(vec2i a, float b) {return (vec2i) { .x = (a.x * b), .y = (a.y * b)};}
        vec2f operator*(vec2f a, float b) {return (vec2f) { .x = (a.x * b), .y = (a.y * b)};}
        vec2d operator*(vec2d a, double b) {return (vec2d) { .x = (a.x * b), .y = (a.y * b)};}

        vec2i operator/(vec2i a, float b) {return (vec2i) { .x = (a.x / b), .y = (a.y / b)};}
        vec2f operator/(vec2f a, float b) {return (vec2f) { .x = (a.x / b), .y = (a.y / b)};}
        vec2d operator/(vec2d a, double b) {return (vec2d) { .x = (a.x / b), .y = (a.y / b)};}

        vec3i operator+(vec3i a, float b) {return (vec3i) { .x = (a.x + b), .y = (a.y + b), .z = (a.z + b)};}
        vec3f operator+(vec3f a, float b) {return (vec3f) { .x = (a.x + b), .y = (a.y + b), .z = (a.z + b)};}
        vec3d operator+(vec3d a, double b) {return (vec3d) { .x = (a.x + b), .y = (a.y + b), .z = (a.z + b)};}

        vec3i operator-(vec3i a, float b) {return (vec3i) { .x = (a.x - b), .y = (a.y - b), .z = (a.z - b)};}
        vec3f operator-(vec3f a, float b) {return (vec3f) { .x = (a.x - b), .y = (a.y - b), .z = (a.z - b)};}
        vec3d operator-(vec3d a, double b) {return (vec3d) { .x = (a.x - b), .y = (a.y - b), .z = (a.z - b)};}

        vec3i operator*(vec3i a, float b) {return (vec3i) { .x = (a.x * b), .y = (a.y * b), .z = (a.z * b)};}
        vec3f operator*(vec3f a, float b) {return (vec3f) { .x = (a.x * b), .y = (a.y * b), .z = (a.z * b)};}
        vec3d operator*(vec3d a, double b) {return (vec3d) { .x = (a.x * b), .y = (a.y * b), .z = (a.z * b)};}

        vec3i operator/(vec3i a, float b) {return (vec3i) { .x = (a.x / b), .y = (a.y / b), .z = (a.z / b)};}
        vec3f operator/(vec3f a, float b) {return (vec3f) { .x = (a.x / b), .y = (a.y / b), .z = (a.z / b)};}
        vec3d operator/(vec3d a, double b) {return (vec3d) { .x = (a.x / b), .y = (a.y / b), .z = (a.z / b)};}

        vec4i operator+(vec4i a, float b) {return (vec4i) { .x = (a.x + b), .y = (a.y + b), .z = (a.z + b), .w = (a.w + b)};}
        vec4f operator+(vec4f a, float b) {return (vec4f) { .x = (a.x + b), .y = (a.y + b), .z = (a.z + b), .w = (a.w + b)};}
        vec4d operator+(vec4d a, double b) {return (vec4d) { .x = (a.x + b), .y = (a.y + b), .z = (a.z + b), .w = (a.w + b)};}

        vec4i operator-(vec4i a, float b) {return (vec4i) { .x = (a.x - b), .y = (a.y - b), .z = (a.z - b), .w = (a.w - b)};}
        vec4f operator-(vec4f a, float b) {return (vec4f) { .x = (a.x - b), .y = (a.y - b), .z = (a.z - b), .w = (a.w - b)};}
        vec4d operator-(vec4d a, double b) {return (vec4d) { .x = (a.x - b), .y = (a.y - b), .z = (a.z - b), .w = (a.w - b)};}

        vec4i operator*(vec4i a, float b) {return (vec4i) { .x = (a.x * b), .y = (a.y * b), .z = (a.z * b), .w = (a.w * b)};}
        vec4f operator*(vec4f a, float b) {return (vec4f) { .x = (a.x * b), .y = (a.y * b), .z = (a.z * b), .w = (a.w * b)};}
        vec4d operator*(vec4d a, double b) {return (vec4d) { .x = (a.x * b), .y = (a.y * b), .z = (a.z * b), .w = (a.w * b)};}

        vec4i operator/(vec4i a, float b) {return (vec4i) { .x = (a.x / b), .y = (a.y / b), .z = (a.z / b), .w = (a.w / b)};}
        vec4f operator/(vec4f a, float b) {return (vec4f) { .x = (a.x / b), .y = (a.y / b), .z = (a.z / b), .w = (a.w / b)};}
        vec4d operator/(vec4d a, double b) {return (vec4d) { .x = (a.x / b), .y = (a.y / b), .z = (a.z / b), .w = (a.w / b)};}

        vec2i operator+(float a, vec2i b) {return (vec2i) { .x = (a + b.x), .y = (a + b.y)};}
        vec2f operator+(float a, vec2f b) {return (vec2f) { .x = (a + b.x), .y = (a + b.y)};}
        vec2d operator+(double a, vec2d b) {return (vec2d) { .x = (a + b.x), .y = (a + b.y)};}

        vec3i operator+(float a, vec3i b) {return (vec3i) { .x = (a + b.x), .y = (a + b.y), .z = (a + b.z)};}
        vec3f operator+(float a, vec3f b) {return (vec3f) { .x = (a + b.x), .y = (a + b.y), .z = (a + b.z)};}
        vec3d operator+(double a, vec3d b) {return (vec3d) { .x = (a + b.x), .y = (a + b.y), .z = (a + b.z)};}

        vec4i operator+(float a, vec4i b) {return (vec4i) { .x = (a + b.x), .y = (a + b.y), .z = (a + b.z), .w = (a + b.w)};}
        vec4f operator+(float a, vec4f b) {return (vec4f) { .x = (a + b.x), .y = (a + b.y), .z = (a + b.z), .w = (a + b.w)};}
        vec4d operator+(double a, vec4d b) {return (vec4d) { .x = (a + b.x), .y = (a + b.y), .z = (a + b.z), .w = (a + b.w)};}

        vec2i operator-(float a, vec2i b) {return (vec2i) { .x = (a - b.x), .y = (a - b.y)};}
        vec2f operator-(float a, vec2f b) {return (vec2f) { .x = (a - b.x), .y = (a - b.y)};}
        vec2d operator-(double a, vec2d b) {return (vec2d) { .x = (a - b.x), .y = (a - b.y)};}

        vec3i operator-(float a, vec3i b) {return (vec3i) { .x = (a - b.x), .y = (a - b.y), .z = (a - b.z)};}
        vec3f operator-(float a, vec3f b) {return (vec3f) { .x = (a - b.x), .y = (a - b.y), .z = (a - b.z)};}
        vec3d operator-(double a, vec3d b) {return (vec3d) { .x = (a - b.x), .y = (a - b.y), .z = (a - b.z)};}

        vec4i operator-(float a, vec4i b) {return (vec4i) { .x = (a - b.x), .y = (a - b.y), .z = (a - b.z), .w = (a - b.w)};}
        vec4f operator-(float a, vec4f b) {return (vec4f) { .x = (a - b.x), .y = (a - b.y), .z = (a - b.z), .w = (a - b.w)};}
        vec4d operator-(double a, vec4d b) {return (vec4d) { .x = (a - b.x), .y = (a - b.y), .z = (a - b.z), .w = (a - b.w)};}

        vec2i operator*(float a, vec2i b) {return (vec2i) { .x = (a * b.x), .y = (a * b.y)};}
        vec2f operator*(float a, vec2f b) {return (vec2f) { .x = (a * b.x), .y = (a * b.y)};}
        vec2d operator*(double a, vec2d b) {return (vec2d) { .x = (a * b.x), .y = (a * b.y)};}

        vec3i operator*(float a, vec3i b) {return (vec3i) { .x = (a * b.x), .y = (a * b.y), .z = (a * b.z)};}
        vec3f operator*(float a, vec3f b) {return (vec3f) { .x = (a * b.x), .y = (a * b.y), .z = (a * b.z)};}
        vec3d operator*(double a, vec3d b) {return (vec3d) { .x = (a * b.x), .y = (a * b.y), .z = (a * b.z)};}

        vec4i operator*(float a, vec4i b) {return (vec4i) { .x = (a * b.x), .y = (a * b.y), .z = (a * b.z), .w = (a * b.w)};}
        vec4f operator*(float a, vec4f b) {return (vec4f) { .x = (a * b.x), .y = (a * b.y), .z = (a * b.z), .w = (a * b.w)};}
        vec4d operator*(double a, vec4d b) {return (vec4d) { .x = (a * b.x), .y = (a * b.y), .z = (a * b.z), .w = (a * b.w)};}

        vec2i operator/(float a, vec2i b) {return (vec2i) { .x = (a / b.x), .y = (a / b.y)};}
        vec2f operator/(float a, vec2f b) {return (vec2f) { .x = (a / b.x), .y = (a / b.y)};}
        vec2d operator/(double a, vec2d b) {return (vec2d) { .x = (a / b.x), .y = (a / b.y)};}

        vec3i operator/(float a, vec3i b) {return (vec3i) { .x = (a / b.x), .y = (a / b.y), .z = (a / b.z)};}
        vec3f operator/(float a, vec3f b) {return (vec3f) { .x = (a / b.x), .y = (a / b.y), .z = (a / b.z)};}
        vec3d operator/(double a, vec3d b) {return (vec3d) { .x = (a / b.x), .y = (a / b.y), .z = (a / b.z)};}

        vec4i operator/(float a, vec4i b) {return (vec4i) { .x = (a / b.x), .y = (a / b.y), .z = (a / b.z), .w = (a / b.w)};}
        vec4f operator/(float a, vec4f b) {return (vec4f) { .x = (a / b.x), .y = (a / b.y), .z = (a / b.z), .w = (a / b.w)};}
        vec4d operator/(double a, vec4d b) {return (vec4d) { .x = (a / b.x), .y = (a / b.y), .z = (a / b.z), .w = (a / b.w)};}

        int operator[](vec2i v, int i) {if(i == 0) return v.x; else return v.y;}
        float operator[](vec2f v, int i) {if(i == 0) return v.x; else return v.y;}
        double operator[](vec2d v, int i) {if(i == 0) return v.x; else return v.y;}

        int operator[](vec3i v, int i) {if(i == 0) return v.x; else if(i == 1) return v.y; else return v.z;}
        float operator[](vec3f v, int i) {if(i == 0) return v.x; else if(i == 1) return v.y; else return v.z;}
        double operator[](vec3d v, int i) {if(i == 0) return v.x; else if(i == 1) return v.y; else return v.z;}

        int operator[](vec4i v, int i) {if(i == 0) return v.x; else if(i == 1) return v.y; else if(i == 2) return v.z; else return v.w;}
        float operator[](vec4f v, int i) {if(i == 0) return v.x; else if(i == 1) return v.y; else if(i == 2) return v.z; else return v.w;}
        double operator[](vec4d v, int i) {if(i == 0) return v.x; else if(i == 1) return v.y; else if(i == 2) return v.z; else return v.w;}

        vec2i v_normal(vec2i v) {return (v * (1 / (float) sqrt(v.x*v.x + v.y*v.y)));}
        vec2f v_normal(vec2f v) {return (v * (1 / (float) sqrt(v.x*v.x + v.y*v.y)));}
        vec2d v_normal(vec2d v) {return (v * (1 / (double) sqrt(v.x*v.x + v.y*v.y)));}

        vec3i v_normal(vec3i v) {return (v * (1 / (float) sqrt(v.x*v.x + v.y*v.y + v.z*v.z)));}
        vec3f v_normal(vec3f v) {return (v * (1 / (float) sqrt(v.x*v.x + v.y*v.y + v.z*v.z)));}
        vec3d v_normal(vec3d v) {return (v * (1 / (double) sqrt(v.x*v.x + v.y*v.y + v.z*v.z)));}

        vec4i v_normal(vec4i v) {return (v * (1 / (float) sqrt(v.x*v.x + v.y*v.y + v.z*v.z + v.w*v.w)));}
        vec4f v_normal(vec4f v) {return (v * (1 / (float) sqrt(v.x*v.x + v.y*v.y + v.z*v.z + v.w*v.w)));}
        vec4d v_normal(vec4d v) {return (v * (1 / (double) sqrt(v.x*v.x + v.y*v.y + v.z*v.z + v.w*v.w)));}

        void v_normal(vec2i *v) {
            float len = (float) sqrt(v->x*v->x + v->y*v->y);
            v->x = (int)(v->x * len);
            v->y = (int)(v->y * len);
        }
        void v_normal(vec2f *v) {
            float len = (float) sqrt(v->x*v->x + v->y*v->y);
            v->x = (v->x * len);
            v->y = (v->y * len);
        }
        void v_normal(vec2d *v) {
            double len = (double) sqrt(v->x*v->x + v->y*v->y);
            v->x = (v->x * len);
            v->y = (v->y * len);
        }

        void v_normal(vec3i *v) {
            float len = (float) sqrt(v->x*v->x + v->y*v->y + v->z*v->z);
            v->x = (int)(v->x * len);
            v->y = (int)(v->y * len);
            v->z = (int)(v->z * len);
        }
        void v_normal(vec3f *v) {
            float len = (float) sqrt(v->x*v->x + v->y*v->y + v->z*v->z);
            v->x = (v->x * len);
            v->y = (v->y * len);
            v->z = (v->z * len);
        }
        void v_normal(vec3d *v) {
            double len = (double) sqrt(v->x*v->x + v->y*v->y + v->z*v->z);
            v->x = (v->x * len);
            v->y = (v->y * len);
            v->z = (v->z * len);
        }

        void v_normal(vec4i *v) {
            float len = (float) sqrt(v->x*v->x + v->y*v->y + v->z*v->z + v->w*v->w);
            v->x = (int)(v->x * len);
            v->y = (int)(v->y * len);
            v->z = (int)(v->z * len);
            v->w = (int)(v->w * len);
        }
        void v_normal(vec4f *v) {
            float len = (float) sqrt(v->x*v->x + v->y*v->y + v->z*v->z + v->w*v->w);
            v->x = (v->x * len);
            v->y = (v->y * len);
            v->z = (v->z * len);
            v->w = (v->w * len);
        }
        void v_normal(vec4d *v) {
            double len = (double) sqrt(v->x*v->x + v->y*v->y + v->z*v->z + v->w*v->w);
            v->x = (v->x * len);
            v->y = (v->y * len);
            v->z = (v->z * len);
            v->w = (v->w * len);
        }

        int v_dot(vec2i a, vec2i b) {return ((a.x * b.x) + (a.y * b.y));}
        float v_dot(vec2f a, vec2f b) {return ((a.x * b.x) + (a.y * b.y));}
        double v_dot(vec2d a, vec2d b) {return ((a.x * b.x) + (a.y * b.y));}

        int v_dot(vec3i a, vec3i b) {return ((a.x * b.x) + (a.y * b.y) + (a.z * b.z));}
        float v_dot(vec3f a, vec3f b) {return ((a.x * b.x) + (a.y * b.y) + (a.z * b.z));}
        double v_dot(vec3d a, vec3d b) {return ((a.x * b.x) + (a.y * b.y) + (a.z * b.z));}

        int v_dot(vec4i a, vec4i b) {return ((a.x * b.x) + (a.y * b.y) + (a.z * b.z) + (a.w * b.w));}
        float v_dot(vec4f a, vec4f b) {return ((a.x * b.x) + (a.y * b.y) + (a.z * b.z) + (a.w * b.w));}
        double v_dot(vec4d a, vec4d b) {return ((a.x * b.x) + (a.y * b.y) + (a.z * b.z) + (a.w * b.w));}

        int v_cross(vec2i a, vec2i b) {return ((a.x * b.y) - (a.y * b.x));}
        float v_cross(vec2f a, vec2f b) {return ((a.x * b.y) - (a.y * b.x));}
        double v_cross(vec2d a, vec2d b) {return ((a.x * b.y) - (a.y * b.x));}

        vec3i v_cross(vec3i a, vec3i b) {
            return (vec3i) { .x = a.y * b.z - a.z * b.y,
                             .y = a.z * b.x - a.x * b.z,
                             .z = a.x * b.y - a.y * b.x };
        }
        vec3f v_cross(vec3f a, vec3f b) {
            return (vec3f) { .x = a.y * b.z - a.z * b.y,
                             .y = a.z * b.x - a.x * b.z,
                             .z = a.x * b.y - a.y * b.x };
        }
        vec3d v_cross(vec3d a, vec3d b) {
            return (vec3d) { .x = a.y * b.z - a.z * b.y,
                             .y = a.z * b.x - a.x * b.z,
                             .z = a.x * b.y - a.y * b.x };
        }

        void v_print(vec2i v) {printf("2x2 Int Vector {\n\t%d, %d\n}\n", v.x, v.y);}
        void v_print(vec2f v) {printf("2x2 Float Vector {\n\t%f, %f\n}\n", v.x, v.y);}
        void v_print(vec2d v) {printf("2x2 Double Vector {\n\t%f, %f\n}\n", v.x, v.y);}

        void v_print(vec3i v) {printf("3x3 Int Vector {\n\t%d, %d, %d\n}\n", v.x, v.y, v.z);}
        void v_print(vec3f v) {printf("3x3 Float Vector {\n\t%f, %f, %f\n}\n", v.x, v.y, v.z);}
        void v_print(vec3d v) {printf("3x3 Double Vector {\n\t%f, %f, %f\n}\n", v.x, v.y, v.z);}

        void v_print(vec4i v) {printf("4x4 Int Vector {\n\t%d, %d, %d, %d\n}\n", v.x, v.y, v.z, v.w);}
        void v_print(vec4f v) {printf("4x4 Float Vector {\n\t%f, %f, %f, %f\n}\n", v.x, v.y, v.z, v.w);}
        void v_print(vec4d v) {printf("4x4 Double Vector {\n\t%f, %f, %f, %f\n}\n", v.x, v.y, v.z, v.w);}

        void v_print(vec2i *v) {printf("2x2 Int Vector {\n\t%d, %d\n}\n", v->x, v->y);}
        void v_print(vec2f *v) {printf("2x2 Float Vector {\n\t%f, %f\n}\n", v->x, v->y);}
        void v_print(vec2d *v) {printf("2x2 Double Vector {\n\t%f, %f\n}\n", v->x, v->y);}

        void v_print(vec3i *v) {printf("3x3 Int Vector {\n\t%d, %d, %d\n}\n", v->x, v->y, v->z);}
        void v_print(vec3f *v) {printf("3x3 Float Vector {\n\t%f, %f, %f\n}\n", v->x, v->y, v->z);}
        void v_print(vec3d *v) {printf("3x3 Double Vector {\n\t%f, %f, %f\n}\n", v->x, v->y, v->z);}

        void v_print(vec4i *v) {printf("4x4 Int Vector {\n\t%d, %d, %d, %d\n}\n", v->x, v->y, v->z, v->w);}
        void v_print(vec4f *v) {printf("4x4 Float Vector {\n\t%f, %f, %f, %f\n}\n", v->x, v->y, v->z, v->w);}
        void v_print(vec4d *v) {printf("4x4 Double Vector {\n\t%f, %f, %f, %f\n}\n", v->x, v->y, v->z, v->w);}

        bool operator==(mat2i a, mat2i b) {
            return ((a.m[0] == b.m[0]) && (a.m[1] == b.m[1]) &&
                    (a.m[2] == b.m[2]) && (a.m[4] == b.m[4]));
        }
        bool operator==(mat2f a, mat2f b) {
            return ((a.m[0] == b.m[0]) && (a.m[1] == b.m[1]) &&
                    (a.m[2] == b.m[2]) && (a.m[4] == b.m[4]));
        }
        bool operator==(mat2d a, mat2d b) {
            return ((a.m[0] == b.m[0]) && (a.m[1] == b.m[1]) &&
                    (a.m[2] == b.m[2]) && (a.m[3] == b.m[3]));
        }

        bool operator==(mat3i a, mat3i b) {
            return ((a.m[0] == b.m[0]) && (a.m[1] == b.m[1]) &&
                    (a.m[2] == b.m[2]) && (a.m[3] == b.m[3]) &&
                    (a.m[4] == b.m[4]) && (a.m[5] == b.m[5]));
        }
        bool operator==(mat3f a, mat3f b) {
            return ((a.m[0] == b.m[0]) && (a.m[1] == b.m[1]) &&
                    (a.m[2] == b.m[2]) && (a.m[3] == b.m[3]) &&
                    (a.m[4] == b.m[4]) && (a.m[5] == b.m[5]));
        }
        bool operator==(mat3d a, mat3d b) {
            return ((a.m[0] == b.m[0]) && (a.m[1] == b.m[1]) &&
                    (a.m[2] == b.m[2]) && (a.m[3] == b.m[3]) &&
                    (a.m[4] == b.m[4]) && (a.m[5] == b.m[5]));
        }

        bool operator==(mat4i a, mat4i b) {
            return ((a.m[0] == b.m[0]) && (a.m[1] == b.m[1]) &&
                    (a.m[2] == b.m[2]) && (a.m[3] == b.m[3]) &&
                    (a.m[4] == b.m[4]) && (a.m[5] == b.m[5]) &&
                    (a.m[6] == b.m[6]) && (a.m[7] == b.m[7]));
        }
        bool operator==(mat4f a, mat4f b) {
            return ((a.m[0] == b.m[0]) && (a.m[1] == b.m[1]) &&
                    (a.m[2] == b.m[2]) && (a.m[3] == b.m[3]) &&
                    (a.m[4] == b.m[4]) && (a.m[5] == b.m[5]) &&
                    (a.m[6] == b.m[6]) && (a.m[7] == b.m[7]));
        }
        bool operator==(mat4d a, mat4d b) {
            return ((a.m[0] == b.m[0]) && (a.m[1] == b.m[1]) &&
                    (a.m[2] == b.m[2]) && (a.m[3] == b.m[3]) &&
                    (a.m[4] == b.m[4]) && (a.m[5] == b.m[5]) &&
                    (a.m[6] == b.m[6]) && (a.m[7] == b.m[7]));
        }

        mat2i operator+(mat2i a, mat2i b) {
            mat2i c;
            c.m[0] = a.m[0] + b.m[0];
            c.m[1] = a.m[1] + b.m[1];
            c.m[2] = a.m[2] + b.m[2];
            c.m[3] = a.m[3] + b.m[3];
            return c;
        }
        mat2f operator+(mat2f a, mat2f b) {
            mat2f c;
            c.m[0] = a.m[0] + b.m[0];
            c.m[1] = a.m[1] + b.m[1];
            c.m[2] = a.m[2] + b.m[2];
            c.m[3] = a.m[3] + b.m[3];
            return c;
        }
        mat2d operator+(mat2d a, mat2d b) {
            mat2d c;
            c.m[0] = a.m[0] + b.m[0];
            c.m[1] = a.m[1] + b.m[1];
            c.m[2] = a.m[2] + b.m[2];
            c.m[3] = a.m[3] + b.m[3];
            return c;
        }

        mat3i operator+(mat3i a, mat3i b) {
            mat3i c;
            c.m[0] = a.m[0] + b.m[0];
            c.m[1] = a.m[1] + b.m[1];
            c.m[2] = a.m[2] + b.m[2];
            c.m[3] = a.m[3] + b.m[3];
            c.m[4] = a.m[4] + b.m[4];
            c.m[5] = a.m[5] + b.m[5];
            return c;
        }
        mat3f operator+(mat3f a, mat3f b) {
            mat3f c;
            c.m[0] = a.m[0] + b.m[0];
            c.m[1] = a.m[1] + b.m[1];
            c.m[2] = a.m[2] + b.m[2];
            c.m[3] = a.m[3] + b.m[3];
            c.m[4] = a.m[4] + b.m[4];
            c.m[5] = a.m[5] + b.m[5];
            return c;
        }
        mat3d operator+(mat3d a, mat3d b) {
            mat3d c;
            c.m[0] = a.m[0] + b.m[0];
            c.m[1] = a.m[1] + b.m[1];
            c.m[2] = a.m[2] + b.m[2];
            c.m[3] = a.m[3] + b.m[3];
            c.m[4] = a.m[4] + b.m[4];
            c.m[5] = a.m[5] + b.m[5];
            return c;
        }

        mat4i operator+(mat4i a, mat4i b) {
            mat4i c;
            c.m[0] = a.m[0] + b.m[0];
            c.m[1] = a.m[1] + b.m[1];
            c.m[2] = a.m[2] + b.m[2];
            c.m[3] = a.m[3] + b.m[3];
            c.m[4] = a.m[4] + b.m[4];
            c.m[5] = a.m[5] + b.m[5];
            c.m[6] = a.m[6] + b.m[6];
            c.m[7] = a.m[7] + b.m[7];
            return c;
        }
        mat4f operator+(mat4f a, mat4f b) {
            mat4f c;
            c.m[0] = a.m[0] + b.m[0];
            c.m[1] = a.m[1] + b.m[1];
            c.m[2] = a.m[2] + b.m[2];
            c.m[3] = a.m[3] + b.m[3];
            c.m[4] = a.m[4] + b.m[4];
            c.m[5] = a.m[5] + b.m[5];
            c.m[6] = a.m[6] + b.m[6];
            c.m[7] = a.m[7] + b.m[7];
            return c;
        }
        mat4d operator+(mat4d a, mat4d b) {
            mat4d c;
            c.m[0] = a.m[0] + b.m[0];
            c.m[1] = a.m[1] + b.m[1];
            c.m[2] = a.m[2] + b.m[2];
            c.m[3] = a.m[3] + b.m[3];
            c.m[4] = a.m[4] + b.m[4];
            c.m[5] = a.m[5] + b.m[5];
            c.m[6] = a.m[6] + b.m[6];
            c.m[7] = a.m[7] + b.m[7];
            return c;
        }

        mat2i operator-(mat2i a, mat2i b) {
            mat2i c;
            c.m[0] = a.m[0] - b.m[0];
            c.m[1] = a.m[1] - b.m[1];
            c.m[2] = a.m[2] - b.m[2];
            c.m[3] = a.m[3] - b.m[3];
            return c;
        }
        mat2f operator-(mat2f a, mat2f b) {
            mat2f c;
            c.m[0] = a.m[0] - b.m[0];
            c.m[1] = a.m[1] - b.m[1];
            c.m[2] = a.m[2] - b.m[2];
            c.m[3] = a.m[3] - b.m[3];
            return c;
        }
        mat2d operator-(mat2d a, mat2d b) {
            mat2d c;
            c.m[0] = a.m[0] - b.m[0];
            c.m[1] = a.m[1] - b.m[1];
            c.m[2] = a.m[2] - b.m[2];
            c.m[3] = a.m[3] - b.m[3];
            return c;
        }

        mat3i operator-(mat3i a, mat3i b) {
            mat3i c;
            c.m[0] = a.m[0] - b.m[0];
            c.m[1] = a.m[1] - b.m[1];
            c.m[2] = a.m[2] - b.m[2];
            c.m[3] = a.m[3] - b.m[3];
            c.m[4] = a.m[4] - b.m[4];
            c.m[5] = a.m[5] - b.m[5];
            return c;
        }
        mat3f operator-(mat3f a, mat3f b) {
            mat3f c;
            c.m[0] = a.m[0] - b.m[0];
            c.m[1] = a.m[1] - b.m[1];
            c.m[2] = a.m[2] - b.m[2];
            c.m[3] = a.m[3] - b.m[3];
            c.m[4] = a.m[4] - b.m[4];
            c.m[5] = a.m[5] - b.m[5];
            return c;
        }
        mat3d operator-(mat3d a, mat3d b) {
            mat3d c;
            c.m[0] = a.m[0] - b.m[0];
            c.m[1] = a.m[1] - b.m[1];
            c.m[2] = a.m[2] - b.m[2];
            c.m[3] = a.m[3] - b.m[3];
            c.m[4] = a.m[4] - b.m[4];
            c.m[5] = a.m[5] - b.m[5];
            return c;
        }

        mat4i operator-(mat4i a, mat4i b) {
            mat4i c;
            c.m[0] = a.m[0] - b.m[0];
            c.m[1] = a.m[1] - b.m[1];
            c.m[2] = a.m[2] - b.m[2];
            c.m[3] = a.m[3] - b.m[3];
            c.m[4] = a.m[4] - b.m[4];
            c.m[5] = a.m[5] - b.m[5];
            c.m[6] = a.m[6] - b.m[6];
            c.m[7] = a.m[7] - b.m[7];
            return c;
        }
        mat4f operator-(mat4f a, mat4f b) {
            mat4f c;
            c.m[0] = a.m[0] - b.m[0];
            c.m[1] = a.m[1] - b.m[1];
            c.m[2] = a.m[2] - b.m[2];
            c.m[3] = a.m[3] - b.m[3];
            c.m[4] = a.m[4] - b.m[4];
            c.m[5] = a.m[5] - b.m[5];
            c.m[6] = a.m[6] - b.m[6];
            c.m[7] = a.m[7] - b.m[7];
            return c;
        }
        mat4d operator-(mat4d a, mat4d b) {
            mat4d c;
            c.m[0] = a.m[0] - b.m[0];
            c.m[1] = a.m[1] - b.m[1];
            c.m[2] = a.m[2] - b.m[2];
            c.m[3] = a.m[3] - b.m[3];
            c.m[4] = a.m[4] - b.m[4];
            c.m[5] = a.m[5] - b.m[5];
            c.m[6] = a.m[6] - b.m[6];
            c.m[7] = a.m[7] - b.m[7];
            return c;
        }

        mat2i operator*(mat2i a, int b) {
            mat2i c;
            c.m[0] = a.m[0] * b;
            c.m[1] = a.m[1] * b;
            c.m[2] = a.m[2] * b;
            c.m[3] = a.m[3] * b;
            return c;
        }
        mat2f operator*(mat2f a, float b) {
            mat2f c;
            c.m[0] = a.m[0] * b;
            c.m[1] = a.m[1] * b;
            c.m[2] = a.m[2] * b;
            c.m[3] = a.m[3] * b;
            return c;
        }
        mat2d operator*(mat2d a, double b) {
            mat2d c;
            c.m[0] = a.m[0] * b;
            c.m[1] = a.m[1] * b;
            c.m[2] = a.m[2] * b;
            c.m[3] = a.m[3] * b;
            return c;
        }

        mat3i operator*(mat3i a, int b) {
            mat3i c;
            c.m[0] = a.m[0] * b;
            c.m[1] = a.m[1] * b;
            c.m[2] = a.m[2] * b;
            c.m[3] = a.m[3] * b;
            c.m[4] = a.m[4] * b;
            c.m[5] = a.m[5] * b;
            return c;
        }
        mat3f operator*(mat3f a, float b) {
            mat3f c;
            c.m[0] = a.m[0] * b;
            c.m[1] = a.m[1] * b;
            c.m[2] = a.m[2] * b;
            c.m[3] = a.m[3] * b;
            c.m[4] = a.m[4] * b;
            c.m[5] = a.m[5] * b;
            return c;
        }
        mat3d operator*(mat3d a, double b) {
            mat3d c;
            c.m[0] = a.m[0] * b;
            c.m[1] = a.m[1] * b;
            c.m[2] = a.m[2] * b;
            c.m[3] = a.m[3] * b;
            c.m[4] = a.m[4] * b;
            c.m[5] = a.m[5] * b;
            return c;
        }

        mat4i operator*(mat4i a, int b) {
            mat4i c;
            c.m[0] = a.m[0] * b;
            c.m[1] = a.m[1] * b;
            c.m[2] = a.m[2] * b;
            c.m[3] = a.m[3] * b;
            c.m[4] = a.m[4] * b;
            c.m[5] = a.m[5] * b;
            c.m[6] = a.m[6] * b;
            c.m[7] = a.m[7] * b;
            return c;
        }
        mat4f operator*(mat4f a, float b) {
            mat4f c;
            c.m[0] = a.m[0] * b;
            c.m[1] = a.m[1] * b;
            c.m[2] = a.m[2] * b;
            c.m[3] = a.m[3] * b;
            c.m[4] = a.m[4] * b;
            c.m[5] = a.m[5] * b;
            c.m[6] = a.m[6] * b;
            c.m[7] = a.m[7] * b;
            return c;
        }
        mat4d operator*(mat4d a, double b) {
            mat4d c;
            c.m[0] = a.m[0] * b;
            c.m[1] = a.m[1] * b;
            c.m[2] = a.m[2] * b;
            c.m[3] = a.m[3] * b;
            c.m[4] = a.m[4] * b;
            c.m[5] = a.m[5] * b;
            c.m[6] = a.m[6] * b;
            c.m[7] = a.m[7] * b;
            return c;
        }

        mat2i operator/(mat2i a, int b) {
            mat2i c;
            c.m[0] = a.m[0] / b;
            c.m[1] = a.m[1] / b;
            c.m[2] = a.m[2] / b;
            c.m[3] = a.m[3] / b;
            return c;
        }
        mat2f operator/(mat2f a, float b) {
            mat2f c;
            c.m[0] = a.m[0] / b;
            c.m[1] = a.m[1] / b;
            c.m[2] = a.m[2] / b;
            c.m[3] = a.m[3] / b;
            return c;
        }
        mat2d operator/(mat2d a, double b) {
            mat2d c;
            c.m[0] = a.m[0] / b;
            c.m[1] = a.m[1] / b;
            c.m[2] = a.m[2] / b;
            c.m[3] = a.m[3] / b;
            return c;
        }

        mat3i operator/(mat3i a, int b) {
            mat3i c;
            c.m[0] = a.m[0] / b;
            c.m[1] = a.m[1] / b;
            c.m[2] = a.m[2] / b;
            c.m[3] = a.m[3] / b;
            c.m[4] = a.m[4] / b;
            c.m[5] = a.m[5] / b;
            return c;
        }
        mat3f operator/(mat3f a, float b) {
            mat3f c;
            c.m[0] = a.m[0] / b;
            c.m[1] = a.m[1] / b;
            c.m[2] = a.m[2] / b;
            c.m[3] = a.m[3] / b;
            c.m[4] = a.m[4] / b;
            c.m[5] = a.m[5] / b;
            return c;
        }
        mat3d operator/(mat3d a, double b) {
            mat3d c;
            c.m[0] = a.m[0] / b;
            c.m[1] = a.m[1] / b;
            c.m[2] = a.m[2] / b;
            c.m[3] = a.m[3] / b;
            c.m[4] = a.m[4] / b;
            c.m[5] = a.m[5] / b;
            return c;
        }

        mat4i operator/(mat4i a, int b) {
            mat4i c;
            c.m[0] = a.m[0] / b;
            c.m[1] = a.m[1] / b;
            c.m[2] = a.m[2] / b;
            c.m[3] = a.m[3] / b;
            c.m[4] = a.m[4] / b;
            c.m[5] = a.m[5] / b;
            c.m[6] = a.m[6] / b;
            c.m[7] = a.m[7] / b;
            return c;
        }
        mat4f operator/(mat4f a, float b) {
            mat4f c;
            c.m[0] = a.m[0] / b;
            c.m[1] = a.m[1] / b;
            c.m[2] = a.m[2] / b;
            c.m[3] = a.m[3] / b;
            c.m[4] = a.m[4] / b;
            c.m[5] = a.m[5] / b;
            c.m[6] = a.m[6] / b;
            c.m[7] = a.m[7] / b;
            return c;
        }
        mat4d operator/(mat4d a, double b) {
            mat4d c;
            c.m[0] = a.m[0] / b;
            c.m[1] = a.m[1] / b;
            c.m[2] = a.m[2] / b;
            c.m[3] = a.m[3] / b;
            c.m[4] = a.m[4] / b;
            c.m[5] = a.m[5] / b;
            c.m[6] = a.m[6] / b;
            c.m[7] = a.m[7] / b;
            return c;
        }

        vec2i operator*(mat2i m, vec2i v) {
            return (vec2i) { .x = m.m[0] * v.x + m.m[1] * v.y,
                             .y = m.m[2] * v.x + m.m[3] * v.y };
        }
        vec2f operator*(mat2f m, vec2f v) {
            return (vec2f) { .x = m.m[0] * v.x + m.m[1] * v.y,
                             .y = m.m[2] * v.x + m.m[3] * v.y };
        }
        vec2d operator*(mat2d m, vec2d v) {
            return (vec2d) { .x = m.m[0] * v.x + m.m[1] * v.y,
                             .y = m.m[2] * v.x + m.m[3] * v.y };
        }

        vec3i operator*(mat3i m, vec3i v) {
            return (vec3i) { .x = m.m[0] * v.x + m.m[1] * v.y + m.m[2] * v.z,
                             .y = m.m[3] * v.x + m.m[4] * v.y + m.m[5] * v.z,
                             .z = m.m[6] * v.x + m.m[7] * v.y + m.m[8] * v.z };
        }
        vec3f operator*(mat3f m, vec3f v) {
            return (vec3f) { .x = m.m[0] * v.x + m.m[1] * v.y + m.m[2] * v.z,
                             .y = m.m[3] * v.x + m.m[4] * v.y + m.m[5] * v.z,
                             .z = m.m[6] * v.x + m.m[7] * v.y + m.m[8] * v.z };
        }
        vec3d operator*(mat3d m, vec3d v) {
            return (vec3d) { .x = m.m[0] * v.x + m.m[1] * v.y + m.m[2] * v.z,
                             .y = m.m[3] * v.x + m.m[4] * v.y + m.m[5] * v.z,
                             .z = m.m[6] * v.x + m.m[7] * v.y + m.m[8] * v.z };
        }

        vec4i operator*(mat4i m, vec4i v) {
            return (vec4i) { .x = m.m[0] * v.x + m.m[1] * v.y + m.m[2] * v.z + m.m[3] * v.w,
                             .y = m.m[4] * v.x + m.m[5] * v.y + m.m[6] * v.z + m.m[7] * v.w,
                             .z = m.m[8] * v.x + m.m[9] * v.y + m.m[10] * v.z + m.m[11] * v.w,
                             .w = m.m[12] * v.x + m.m[13] * v.y + m.m[14] * v.z + m.m[15] * v.w };
        }
        vec4f operator*(mat4f m, vec4f v) {
            return (vec4f) { .x = m.m[0] * v.x + m.m[1] * v.y + m.m[2] * v.z + m.m[3] * v.w,
                             .y = m.m[4] * v.x + m.m[5] * v.y + m.m[6] * v.z + m.m[7] * v.w,
                             .z = m.m[8] * v.x + m.m[9] * v.y + m.m[10] * v.z + m.m[11] * v.w,
                             .w = m.m[12] * v.x + m.m[13] * v.y + m.m[14] * v.z + m.m[15] * v.w };
        }
        vec4d operator*(mat4d m, vec4d v) {
            return (vec4d) { .x = m.m[0] * v.x + m.m[1] * v.y + m.m[2] * v.z + m.m[3] * v.w,
                             .y = m.m[4] * v.x + m.m[5] * v.y + m.m[6] * v.z + m.m[7] * v.w,
                             .z = m.m[8] * v.x + m.m[9] * v.y + m.m[10] * v.z + m.m[11] * v.w,
                             .w = m.m[12] * v.x + m.m[13] * v.y + m.m[14] * v.z + m.m[15] * v.w };
        }

        mat2i operator*(mat2i a, mat2i b) {
            mat2i ret;
            vec2i col0 = a * (vec2i) { .x = b.m[0], .y = b.m[1] };
            vec2i col1 = a * (vec2i) { .x = b.m[2], .y = b.m[3] };

            ret.m[0] = col0.x;
            ret.m[1] = col0.y;

            ret.m[2] = col1.x;
            ret.m[3] = col1.y;

            return ret;
        }
        mat2f operator*(mat2f a, mat2f b) {
            mat2f ret;
            vec2f col0 = a * (vec2f) { .x = b.m[0], .y = b.m[1] };
            vec2f col1 = a * (vec2f) { .x = b.m[2], .y = b.m[3] };

            ret.m[0] = col0.x;
            ret.m[1] = col0.y;

            ret.m[2] = col1.x;
            ret.m[3] = col1.y;

            return ret;
        }
        mat2d operator*(mat2d a, mat2d b) {
            mat2d ret;
            vec2d col0 = a * (vec2d) { .x = b.m[0], .y = b.m[1] };
            vec2d col1 = a * (vec2d) { .x = b.m[2], .y = b.m[3] };

            ret.m[0] = col0.x;
            ret.m[1] = col0.y;

            ret.m[2] = col1.x;
            ret.m[3] = col1.y;

            return ret;
        }

        mat3i operator*(mat3i a, mat3i b) {
            mat3i ret;

            for(int i = 0; i < 3; i++) {
                vec3i bcol = (vec3i) { .x = b.m[i],
                                       .y = b.m[i + 3],
                                       .z = b.m[i + 6] };
                vec3i acol = a * bcol;

                for(int j = 0; j < 3; j++) {
                    ret.m[i + j * 3] = acol[j];
                }
            }

            return ret;
        }
        mat3f operator*(mat3f a, mat3f b) {
            mat3f ret;

            for(int i = 0; i < 3; i++) {
                vec3f bcol = (vec3f) { .x = b.m[i],
                                       .y = b.m[i + 3],
                                       .z = b.m[i + 6] };
                vec3f acol = a * bcol;

                for(int j = 0; j < 3; j++) {
                    ret.m[i + j * 3] = acol[j];
                }
            }

            return ret;
        }
        mat3d operator*(mat3d a, mat3d b) {
            mat3d ret;

            for(int i = 0; i < 3; i++) {
                vec3d bcol = (vec3d) { .x = b.m[i],
                                       .y = b.m[i + 3],
                                       .z = b.m[i + 6] };
                vec3d acol = a * bcol;

                for(int j = 0; j < 3; j++) {
                    ret.m[i + j * 3] = acol[j];
                }
            }

            return ret;
        }

        mat4i operator*(mat4i a, mat4i b) {
            mat4i ret;

            for(int i = 0; i < 4; i++) {
                vec4i bcol = (vec4i) { .x = b.m[i],
                                       .y = b.m[i + 4],
                                       .z = b.m[i + 8],
                                       .w = b.m[i + 12] };
                vec4i acol = a * bcol;

                for(int j = 0; j < 4; j++) {
                    ret.m[i + j * 4] = acol[j];
                }
            }

            return ret;
        }
        mat4f operator*(mat4f a, mat4f b) {
            mat4f ret;

            for(int i = 0; i < 4; i++) {
                vec4f bcol = (vec4f) { .x = b.m[i],
                                       .y = b.m[i + 4],
                                       .z = b.m[i + 8],
                                       .w = b.m[i + 12] };
                vec4f acol = a * bcol;

                for(int j = 0; j < 4; j++) {
                    ret.m[i + j * 4] = acol[j];
                }
            }

            return ret;
        }
        mat4d operator*(mat4d a, mat4d b) {
            mat4d ret;

            for(int i = 0; i < 4; i++) {
                vec4d bcol = (vec4d) { .x = b.m[i],
                                       .y = b.m[i + 4],
                                       .z = b.m[i + 8],
                                       .w = b.m[i + 12] };
                vec4d acol = a * bcol;

                for(int j = 0; j < 4; j++) {
                    ret.m[i + j * 4] = acol[j];
                }
            }

            return ret;
        }

        void m_identity(mat2i *m) {
            m->m[0] = 1;
            m->m[1] = 0;
            m->m[2] = 0;
            m->m[3] = 1;
        }
        void m_identity(mat2f *m) {
            m->m[0] = 1;
            m->m[1] = 0;
            m->m[2] = 0;
            m->m[3] = 1;
        }
        void m_identity(mat2d *m) {
            m->m[0] = 1;
            m->m[1] = 0;
            m->m[2] = 0;
            m->m[3] = 1;
        }

        void m_identity(mat3i *m) {
            m->m[0] = 1;
            m->m[1] = 0;
            m->m[2] = 0;
            m->m[3] = 0;
            m->m[4] = 1;
            m->m[5] = 0;
            m->m[6] = 0;
            m->m[7] = 0;
            m->m[8] = 1;
        }
        void m_identity(mat3f *m) {
            m->m[0] = 1;
            m->m[1] = 0;
            m->m[2] = 0;
            m->m[3] = 0;
            m->m[4] = 1;
            m->m[5] = 0;
            m->m[6] = 0;
            m->m[7] = 0;
            m->m[8] = 1;
        }
        void m_identity(mat3d *m) {
            m->m[0] = 1;
            m->m[1] = 0;
            m->m[2] = 0;
            m->m[3] = 0;
            m->m[4] = 1;
            m->m[5] = 0;
            m->m[6] = 0;
            m->m[7] = 0;
            m->m[8] = 1;
        }

        void m_identity(mat4i *m) {
            for(int i = 0; i < 16; i++) {
                if(i % 5 == 0) {
                    m->m[i] = 1;
                } else {
                    m->m[i] = 0;
                }
            }
        }
        void m_identity(mat4f *m) {
            for(int i = 0; i < 16; i++) {
                if(i % 5 == 0) {
                    m->m[i] = 1;
                } else {
                    m->m[i] = 0;
                }
            }
        }
        void m_identity(mat4d *m) {
            for(int i = 0; i < 16; i++) {
                if(i % 5 == 0) {
                    m->m[i] = 1;
                } else {
                    m->m[i] = 0;
                }
            }
        }

        mat2i m_identity2i() {
            mat2i ret;
            m_identity(&ret);
            return ret;
        }
        mat2f m_identity2f() {
            mat2f ret;
            m_identity(&ret);
            return ret;
        }
        mat2d m_identity2d() {
            mat2d ret;
            m_identity(&ret);
            return ret;
        }

        mat3i m_identity3i() {
            mat3i ret;
            m_identity(&ret);
            return ret;
        }
        mat3f m_identity3f() {
            mat3f ret;
            m_identity(&ret);
            return ret;
        }
        mat3d m_identity3d() {
            mat3d ret;
            m_identity(&ret);
            return ret;
        }

        mat4i m_identity4i() {
            mat4i ret;
            m_identity(&ret);
            return ret;
        }
        mat4f m_identity4f() {
            mat4f ret;
            m_identity(&ret);
            return ret;
        }
        mat4d m_identity4d() {
            mat4d ret;
            m_identity(&ret);
            return ret;
        }

        void m_transpose(mat2i *m) {
            int tmp = m->m[1];
            m->m[1] = m->m[2];
            m->m[2] = tmp;
        }
        void m_transpose(mat2f *m) {
            float tmp = m->m[1];
            m->m[1] = m->m[2];
            m->m[2] = tmp;
        }
        void m_transpose(mat2d *m) {
            double tmp = m->m[1];
            m->m[1] = m->m[2];
            m->m[2] = tmp;
        }

        void m_transpose(mat3i *m) {
            mat3i temp;

            for(int i = 0; i < 3; i++) {
                for(int j = 0; j < 3; j++) {
                    temp.m[i + j * 3] = m->m[i * 3 + j];
                }
            }

            for(int i = 0; i < 9; i++) {
                m->m[i] = temp.m[i];
            }
        }
        void m_transpose(mat3f *m) {
            mat3f temp;

            for(int i = 0; i < 3; i++) {
                for(int j = 0; j < 3; j++) {
                    temp.m[i + j * 3] = m->m[i * 3 + j];
                }
            }

            for(int i = 0; i < 9; i++) {
                m->m[i] = temp.m[i];
            }
        }
        void m_transpose(mat3d *m) {
            mat3d temp;

            for(int i = 0; i < 3; i++) {
                for(int j = 0; j < 3; j++) {
                    temp.m[i + j * 3] = m->m[i * 3 + j];
                }
            }

            for(int i = 0; i < 9; i++) {
                m->m[i] = temp.m[i];
            }
        }

        void m_transpose(mat4i *m) {
            mat4i temp;

            for(int i = 0; i < 4; i++) {
                for(int j = 0; j < 4; j++) {
                    temp.m[i + j * 4] = m->m[i * 4 + j];
                }
            }

            for(int i = 0; i < 16; i++) {
                m->m[i] = temp.m[i];
            }
        }
        void m_transpose(mat4f *m) {
            mat4f temp;

            for(int i = 0; i < 4; i++) {
                for(int j = 0; j < 4; j++) {
                    temp.m[i + j * 4] = m->m[i * 4 + j];
                }
            }

            for(int i = 0; i < 16; i++) {
                m->m[i] = temp.m[i];
            }
        }
        void m_transpose(mat4d *m) {
            mat4d temp;

            for(int i = 0; i < 4; i++) {
                for(int j = 0; j < 4; j++) {
                    temp.m[i + j * 4] = m->m[i * 4 + j];
                }
            }

            for(int i = 0; i < 16; i++) {
                m->m[i] = temp.m[i];
            }
        }

        mat2i m_transpose(mat2i m) {
            mat2i ret = (mat2i) {
                .m = {
                    1, 0, 0, 1
                }
            };

            return ret;
        }
        mat2f m_transpose(mat2f m) {
            mat2f ret = (mat2f) {
                .m = {
                    1, 0, 0, 1
                }
            };

            return ret;
        }
        mat2d m_transpose(mat2d m) {
            mat2d ret = (mat2d) {
                .m = {
                    1, 0, 0, 1
                }
            };

            return ret;
        }

        mat3i m_transpose(mat3i m) {
            mat3i ret;

            for(int i = 0; i < 3; i++) {
                for(int j = 0; j < 3; j++) {
                    ret.m[i + j * 3] = m.m[i * 3 + j];
                }
            }

            return ret;
        }
        mat3f m_transpose(mat3f m) {
            mat3f ret;

            for(int i = 0; i < 3; i++) {
                for(int j = 0; j < 3; j++) {
                    ret.m[i + j * 3] = m.m[i * 3 + j];
                }
            }

            return ret;
        }
        mat3d m_transpose(mat3d m) {
            mat3d ret;

            for(int i = 0; i < 3; i++) {
                for(int j = 0; j < 3; j++) {
                    ret.m[i + j * 3] = m.m[i * 3 + j];
                }
            }

            return ret;
        }

        mat4i m_transpose(mat4i m) {
            mat4i ret;

            for(int i = 0; i < 4; i++) {
                for(int j = 0; j < 4; j++) {
                    ret.m[i + j * 4] = m.m[i * 4 + j];
                }
            }

            return ret;
        }
        mat4f m_transpose(mat4f m) {
            mat4f ret;

            for(int i = 0; i < 4; i++) {
                for(int j = 0; j < 4; j++) {
                    ret.m[i + j * 4] = m.m[i * 4 + j];
                }
            }

            return ret;
        }
        mat4d m_transpose(mat4d m) {
            mat4d ret;

            for(int i = 0; i < 4; i++) {
                for(int j = 0; j < 4; j++) {
                    ret.m[i + j * 4] = m.m[i * 4 + j];
                }
            }

            return ret;
        }

        int m_determinant(mat2i m) {
            return m.m[0] * m.m[3] - m.m[1] * m.m[2];
        }
        float m_determinant(mat2f m) {
            return m.m[0] * m.m[3] - m.m[1] * m.m[2];
        }
        double m_determinant(mat2d m) {
            return m.m[0] * m.m[3] - m.m[1] * m.m[2];
        }

        int m_determinant(mat3i m) {
            int r0 = m.m[0] * m.m[4] * m.m[8];
            int r1 = m.m[1] * m.m[5] * m.m[6];
            int r2 = m.m[2] * m.m[3] * m.m[7];

            int l0 = m.m[0] * m.m[5] * m.m[7];
            int l1 = m.m[1] * m.m[3] * m.m[8];
            int l2 = m.m[2] * m.m[4] * m.m[6];

            return r0 - r1 - r2 + l0 + l1 + l2;
        }
        float m_determinant(mat3f m) {
            float r0 = m.m[0] * m.m[4] * m.m[8];
            float r1 = m.m[1] * m.m[5] * m.m[6];
            float r2 = m.m[2] * m.m[3] * m.m[7];

            float l0 = m.m[0] * m.m[5] * m.m[7];
            float l1 = m.m[1] * m.m[3] * m.m[8];
            float l2 = m.m[2] * m.m[4] * m.m[6];

            return r0 - r1 - r2 + l0 + l1 + l2;
        }
        double m_determinant(mat3d m) {
            double r0 = m.m[0] * m.m[4] * m.m[8];
            double r1 = m.m[1] * m.m[5] * m.m[6];
            double r2 = m.m[2] * m.m[3] * m.m[7];

            double l0 = m.m[0] * m.m[5] * m.m[7];
            double l1 = m.m[1] * m.m[3] * m.m[8];
            double l2 = m.m[2] * m.m[4] * m.m[6];

            return r0 - r1 - r2 + l0 + l1 + l2;
        }

        mat2i m_minor(mat3i m, int row, int col) {
            mat2i ret = m_identity2i();
            int m2index = 0;

            for(int i = 0; i < 3; i++) {
                if(i == col) continue;
                for(int j = 0; j < 3; j++) {
                    if(j == row) continue;
                    ret.m[m2index] = m.m[i * 3 + j];
                    m2index++;
                }
            }

            return ret;
        }
        mat2f m_minor(mat3f m, int row, int col) {
            mat2f ret = m_identity2f();
            int m2index = 0;

            for(int i = 0; i < 3; i++) {
                if(i == col) continue;
                for(int j = 0; j < 3; j++) {
                    if(j == row) continue;
                    ret.m[m2index] = m.m[i * 3 + j];
                    m2index++;
                }
            }

            return ret;
        }
        mat2d m_minor(mat3d m, int row, int col) {
            mat2d ret = m_identity2d();
            int m2index = 0;

            for(int i = 0; i < 3; i++) {
                if(i == col) continue;
                for(int j = 0; j < 3; j++) {
                    if(j == row) continue;
                    ret.m[m2index] = m.m[i * 3 + j];
                    m2index++;
                }
            }

            return ret;
        }

        mat3i m_minor(mat4i m, int row, int col) {
            mat3i ret = m_identity3i();
            int m2index = 0;

            for(int i = 0; i < 4; i++) {
                if(i == col) continue;
                for(int j = 0; j < 4; j++) {
                    if(j == row) continue;
                    ret.m[m2index] = m.m[i * 4 + j];
                    m2index++;
                }
            }

            return ret;
        }
        mat3f m_minor(mat4f m, int row, int col) {
            mat3f ret = m_identity3f();
            int m2index = 0;

            for(int i = 0; i < 4; i++) {
                if(i == col) continue;
                for(int j = 0; j < 4; j++) {
                    if(j == row) continue;
                    ret.m[m2index] = m.m[i * 4 + j];
                    m2index++;
                }
            }

            return ret;
        }
        mat3d m_minor(mat4d m, int row, int col) {
            mat3d ret = m_identity3d();
            int m2index = 0;

            for(int i = 0; i < 4; i++) {
                if(i == col) continue;
                for(int j = 0; j < 4; j++) {
                    if(j == row) continue;
                    ret.m[m2index] = m.m[i * 4 + j];
                    m2index++;
                }
            }

            return ret;
        }

        int m_determinant(mat4i m) {
            int ret = 0;

            for(int i = 0; i < 4; i++) {
                int f = m.m[i] * m_determinant(m_minor(m, 0, i));
                if(i % 2 == 1) f *= -1;
                ret += f;
            }

            return ret;
        }
        float m_determinant(mat4f m) {
            float ret = 0;

            for(int i = 0; i < 4; i++) {
                float f = m.m[i] * m_determinant(m_minor(m, 0, i));
                if(i % 2 == 1) f *= -1;
                ret += f;
            }

            return ret;
        }
        double m_determinant(mat4d m) {
            double ret = 0;

            for(int i = 0; i < 4; i++) {
                double f = m.m[i] * m_determinant(m_minor(m, 0, i));
                if(i % 2 == 1) f *= -1;
                ret += f;
            }

            return ret;
        }

        mat2i m_inverse(mat2i m) {
            mat2i ret;

            int det = (int) (1 / m_determinant(m));

            ret = (mat2i) {
                .m = {
                    m.m[3] * det, -m.m[1] * det,
                    -m.m[2] * det, m.m[0] * det
                }
            };

            return ret;
        }
        mat2f m_inverse(mat2f m) {
            mat2f ret;

            float det = 1 / m_determinant(m);

            ret = (mat2f) {
                .m = {
                    m.m[3] * det, -m.m[1] * det,
                    -m.m[2] * det, m.m[0] * det
                }
            };

            return ret;
        }
        mat2d m_inverse(mat2d m) {
            mat2d ret;

            double det = 1 / m_determinant(m);

            ret = (mat2d) {
                .m = {
                    m.m[3] * det, -m.m[1] * det,
                    -m.m[2] * det, m.m[0] * det
                }
            };

            return ret;
        }
        
        mat3i m_inverse(mat3i m) {
            int det = m_determinant(m);
            if(det == 0) return m_identity3i();

            int idet = (int) (1 / det);
            mat3i cofactor;

            for(int i = 0; i < 9; i++) {
                cofactor.m[i] = m_determinant(m_minor(m, (int) (i / 3), i % 3));

                if((i % 2) == 1) cofactor.m[i] *= -1;
                if((i / 4) % 2 == 1) cofactor.m[i] *= -1;
            }

            return cofactor * idet;
        }
        mat3f m_inverse(mat3f m) {
            float det = m_determinant(m);
            if(det == 0) return m_identity3f();

            float idet = 1 / det;
            mat3f cofactor;

            for(int i = 0; i < 9; i++) {
                cofactor.m[i] = m_determinant(m_minor(m, (int) (i / 3), i % 3));

                if((i % 2) == 1) cofactor.m[i] *= -1;
                if((i / 4) % 2 == 1) cofactor.m[i] *= -1;
            }

            return cofactor * idet;
        }
        mat3d m_inverse(mat3d m) {
            double det = m_determinant(m);
            if(det == 0) return m_identity3d();

            double idet = 1 / det;
            mat3d cofactor;

            for(int i = 0; i < 9; i++) {
                cofactor.m[i] = m_determinant(m_minor(m, (int) (i / 3), i % 3));

                if((i % 2) == 1) cofactor.m[i] *= -1;
                if((i / 4) % 2 == 1) cofactor.m[i] *= -1;
            }

            return cofactor * idet;
        }

        mat4i m_inverse(mat4i m) {
            int det = m_determinant(m);
            if(det == 0) return m_identity4i();

            int idet = (int) (1 / det);
            mat4i cofactor;

            for(int i = 0; i < 16; i++) {
                cofactor.m[i] = m_determinant(m_minor(m, (int) (i / 4), i % 4));

                if((i % 2) == 1) cofactor.m[i] *= -1;
                if((i / 4) % 2 == 1) cofactor.m[i] *= -1;
            }

            return cofactor * idet;
        }
        mat4f m_inverse(mat4f m) {
            float det = m_determinant(m);
            if(det == 0) return m_identity4f();

            float idet = 1 / det;
            mat4f cofactor;

            for(int i = 0; i < 16; i++) {
                cofactor.m[i] = m_determinant(m_minor(m, (int) (i / 4), i % 4));

                if((i % 2) == 1) cofactor.m[i] *= -1;
                if((i / 4) % 2 == 1) cofactor.m[i] *= -1;
            }

            return cofactor * idet;
        }
        mat4d m_inverse(mat4d m) {
            double det = m_determinant(m);
            if(det == 0) return m_identity4d();

            double idet = 1 / det;
            mat4d cofactor;

            for(int i = 0; i < 16; i++) {
                cofactor.m[i] = m_determinant(m_minor(m, (int) (i / 4), i % 4));

                if((i % 2) == 1) cofactor.m[i] *= -1;
                if((i / 4) % 2 == 1) cofactor.m[i] *= -1;
            }

            return cofactor * idet;
        }

        mat4i m_ortho(int right, int left, int top, int bottom, int near, int far) {
            mat4i ret;
            m_identity(&ret);

            int i_rminusl = (int) 1 / (right - left);
            int i_tminusb = (int) 1 / (top - bottom);
            int i_fminusn = (int) 1 / (far - near);

            ret.m[0] = 2 * i_rminusl;
            ret.m[5] = 2 * i_tminusb;
            ret.m[10] = -2 * i_fminusn;

            ret.m[3] = (right + left) * -i_rminusl;
            ret.m[7] = (top + bottom) * -i_tminusb;
            ret.m[11] = -(far + near) * -i_fminusn;

            return ret;
        }
        mat4f m_ortho(float right, float left, float top, float bottom, float near, float far) {
            mat4f ret;
            m_identity(&ret);

            float i_rminusl = 1 / (right - left);
            float i_tminusb = 1 / (top - bottom);
            float i_fminusn = 1 / (far - near);

            ret.m[0] = 2 * i_rminusl;
            ret.m[5] = 2 * i_tminusb;
            ret.m[10] = -2 * i_fminusn;

            ret.m[3] = (right + left) * -i_rminusl;
            ret.m[7] = (top + bottom) * -i_tminusb;
            ret.m[11] = -(far + near) * -i_fminusn;

            return ret;
        }
        mat4d m_ortho(double right, double left, double top, double bottom, double near, double far) {
            mat4d ret;
            m_identity(&ret);

            double i_rminusl = 1 / (right - left);
            double i_tminusb = 1 / (top - bottom);
            double i_fminusn = 1 / (far - near);

            ret.m[0] = 2 * i_rminusl;
            ret.m[5] = 2 * i_tminusb;
            ret.m[10] = -2 * i_fminusn;

            ret.m[3] = (right + left) * -i_rminusl;
            ret.m[7] = (top + bottom) * -i_tminusb;
            ret.m[11] = -(far + near) * -i_fminusn;

            return ret;
        }

        mat4i m_perspective(int fov, int aspect, int far, int near) {
            mat4i ret;
            m_identity(&ret);

            int i_fov = (int) 1 / (tan(fov / 2));

            ret.m[0] = (int) (1 / (aspect * i_fov));
            ret.m[5] = (int) (1 / i_fov);
            ret.m[10] = (int) (far / (far - near));
            ret.m[11] = -(far * near) / (far - near);
            ret.m[14] = 1;

            return ret;
        }
        mat4f m_perspective(float fov, float aspect, float far, float near) {
            mat4f ret;
            m_identity(&ret);

            float i_fov = (float) (1 / (tan(fov / 2)));

            ret.m[0] = 1 / (aspect * i_fov);
            ret.m[5] = 1 / i_fov;
            ret.m[10] = far / (far - near);
            ret.m[11] = -(far * near) / (far - near);
            ret.m[14] = 1;

            return ret;
        }
        mat4d m_perspective(double fov, double aspect, double far, double near) {
            mat4d ret;
            m_identity(&ret);

            double i_fov = 1 / (tan(fov / 2));

            ret.m[0] = 1 / (aspect * i_fov);
            ret.m[5] = 1 / i_fov;
            ret.m[10] = far / (far - near);
            ret.m[11] = -(far * near) / (far - near);
            ret.m[14] = 1;

            return ret;
        }

        void m_print(mat2i m) {
            printf("2x2 Int Matrix {\n");
            printf("    %d, %d\n", m.m[0], m.m[1]);
            printf("    %d, %d\n", m.m[2], m.m[3]);
            printf("}\n");
        }
        void m_print(mat2f m) {
            printf("2x2 Float Matrix {\n");
            printf("    %f, %f\n", m.m[0], m.m[1]);
            printf("    %f, %f\n", m.m[2], m.m[3]);
            printf("}\n");
        }
        void m_print(mat2d m) {
            printf("2x2 Double Matrix {\n");
            printf("    %lf, %lf\n", m.m[0], m.m[1]);
            printf("    %lf, %lf\n", m.m[2], m.m[3]);
            printf("}\n");
        }

        void m_print(mat3i m) {
            printf("3x3 Int Matrix {\n");
            printf("    %d, %d, %d\n", m.m[0], m.m[1], m.m[2]);
            printf("    %d, %d, %d\n", m.m[3], m.m[4], m.m[5]);
            printf("    %d, %d, %d\n", m.m[6], m.m[7], m.m[8]);
            printf("}\n");
        }
        void m_print(mat3f m) {
            printf("3x3 Float Matrix {\n");
            printf("    %f, %f, %f\n", m.m[0], m.m[1], m.m[2]);
            printf("    %f, %f, %f\n", m.m[3], m.m[4], m.m[5]);
            printf("    %f, %f, %f\n", m.m[6], m.m[7], m.m[8]);
            printf("}\n");
        }
        void m_print(mat3d m) {
            printf("3x3 Double Matrix {\n");
            printf("    %lf, %lf, %lf\n", m.m[0], m.m[1], m.m[2]);
            printf("    %lf, %lf, %lf\n", m.m[3], m.m[4], m.m[5]);
            printf("    %lf, %lf, %lf\n", m.m[6], m.m[7], m.m[8]);
            printf("}\n");
        }

        void m_print(mat4i m) {
            printf("4x4 Int Matrix {\n");
            printf("    %d, %d, %d, %d\n", m.m[0], m.m[1], m.m[2], m.m[3]);
            printf("    %d, %d, %d, %d\n", m.m[4], m.m[5], m.m[6], m.m[7]);
            printf("    %d, %d, %d, %d\n", m.m[8], m.m[9], m.m[10], m.m[11]);
            printf("    %d, %d, %d, %d\n", m.m[12], m.m[13], m.m[14], m.m[15]);
            printf("}\n");
        }
        void m_print(mat4f m) {
            printf("4x4 Float Matrix {\n");
            printf("    %f, %f, %f, %f\n", m.m[0], m.m[1], m.m[2], m.m[3]);
            printf("    %f, %f, %f, %f\n", m.m[4], m.m[5], m.m[6], m.m[7]);
            printf("    %f, %f, %f, %f\n", m.m[8], m.m[9], m.m[10], m.m[11]);
            printf("    %f, %f, %f, %f\n", m.m[12], m.m[13], m.m[14], m.m[15]);
            printf("}\n");
        }
        void m_print(mat4d m) {
            printf("4x4 Double Matrix {\n");
            printf("    %lf, %lf, %lf, %lf\n", m.m[0], m.m[1], m.m[2], m.m[3]);
            printf("    %lf, %lf, %lf, %lf\n", m.m[4], m.m[5], m.m[6], m.m[7]);
            printf("    %lf, %lf, %lf, %lf\n", m.m[8], m.m[9], m.m[10], m.m[11]);
            printf("    %lf, %lf, %lf, %lf\n", m.m[12], m.m[13], m.m[14], m.m[15]);
            printf("}\n");
        }
    }
}