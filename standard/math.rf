cinclude "math.h";
import "io.rf";

/*
    Functions
    @author: Mr. Hecker (Stolen from the C standard library)
*/
native double acos(double x);
native float acosf(float x);
native double acosh(double x);
native float acoshf(float x);
native double asin(double x);
native float asinf(float x);
native double asinh(double x);
native float asinhf(float x);
native double atan(double x);
native double atan2(double x, double y);
native float atan2f(float x, float y);
native float atanf(float x);
native double atanh(double x);
native float atanhf(float x);
native double cbrt(double x);
native float cbrtf(float x);
native double ceil(double x);
native float ceilf(float x);
native double copysign(double x, double y);
native float copysignf(float x, float y);
native double cos(double x);
native float cosf(float x);
native double cosh(double x);
native float coshf(float x);
native double erf(double x);
native double erfc(double x);
native float erfcf(float x);
native float erff(float x);
native double exp(double x);
native double exp2(double x);
native float exp2f(float x);
native float expf(float x);
native double expm1(double x);
native float expm1f(float x);
native double fabs(double x);
native float fabsf(float x);
native double fdim(double x, double y);
native float fdimf(float x, float y);
native double floor(double x);
native float floorf(float x);
native double fma(double x, double y, double z);
native float fmaf(float x, float y, float z);
native double fmax(double x, double y);
native float fmaxf(float x, float y);
native double fmin(double x, double y);
native float fminf(float x, float y);
native double fmod(double x, double y);
native float fmodf(float x, float y);
native double frexp(double x, int* y);
native float frexpf(float x, int* y);
native double hypot(double x, double y);
native float hypotf(float x, float y);
native int ilogb(double x);
native int ilogbf(float x);
native double ldexp(double x, int y);
native float ldexpf(float x, int y);
native double lgamma(double x);
native float lgammaf(float x);
native long lrint(double x);
native long lrintf(float x);
native long lround(double x);
native long lroundf(float x);
native double log(double x);
native double log10(double x);
native float log10f(float x);
native double log1p(double x);
native float log1pf(float x);
native double log2(double x);
native float log2f(float x);
native double logb(double x);
native float logbf(float x);
native double modf(double x, double* y);
native float modff(float x, float* y);
native double nan(cstring x);
native float nanf(cstring x);
native double nearbyint(double x);
native float nearbyintf(float x);
native double nextafter(double x, double y);
native float nextafterf(float x, float y);
native double pow(double x, double y);
native float powf(float x, float y);
native double remainder(double x, double y);
native float remainderf(float x, float y);
native double remquo(double x, double y, int* z);
native float remquof(float x, float y, int* z);
native double rint(double x);
native float rintf(float x);
native double round(double x);
native float roundf(float x);
native double scalbln(double x, long y);
native float scalblnf(float x, long y);
native double scalbn(double x, int y);
native float scalbnf(float x, int y);
native double sin(double x);
native float sinf(float x);
native double sinh(double x);
native float sinhf(float x);
native double sqrt(double x);
native float sqrtf(float x);
native double tan(double x);
native float tanf(float x);
native double tanh(double x);
native float tanhf(float x);
native double tgamma(double x);
native float tgammaf(float x);
native double trunc(double x);
native float truncf(float x);

namespace std {
    namespace Math {
        native float  INFINITY;         // ((float)(_HUGE_ENUF * _HUGE_ENUF)) Positive infinity
        native double HUGE_VAL;         // ((double)INFINITY)
        native float  HUGE_VALF;        // ((float)INFINITY)
        native float  NAN;              // ((float)(INFINITY * 0.0F)) Not a number
        
        int _DENORM          = (-2);            // IEEE 754: "denormalized"
        int _FINITE          = (-1);            // IEEE 754: "finite"
        int _INFCODE         = 1;               // IEEE 754: "infinite"
        int _NANCODE         = 2;               // IEEE 754: "NaN"
        
        int FP_INFINITE      = 1;           // fpclassify() and isinf()
        int FP_NAN           = 2;           // fpclassify() and isnan()
        int FP_NORMAL        = (-1);        // fpclassify() and isnormal()
        int FP_SUBNORMAL     = (-2);        // fpclassify() and isfinite()
        int FP_ZERO          = 0;           // fpclassify() and iszero()
        
        int FP_ILOGB0        = (2147483647 - 1);
        int FP_ILOGBNAN      = 2147483647;
        
        int MATH_ERRNO       = 1;
        int MATH_ERREXCEPT   = 2;
        int math_errhandling = 1;

        struct vec2i {int x; int y;}
        struct vec2f {float x; float y;}
        struct vec2d {double x; double y;}

        struct vec3i {int x; int y; int z;}
        struct vec3f {float x; float y; float z;}
        struct vec3d {double x; double y; double z;}

        struct vec4i {int x; int y; int z; int w;}
        struct vec4f {float x; float y; float z; float w;}
        struct vec4d {double x; double y; double z; double w;}

        struct mat2i {int[4] m;}
        struct mat2f {float[4] m;}
        struct mat2d {double[4] m;}

        struct mat3i {int[9] m;}
        struct mat3f {float[9] m;}
        struct mat3d {double[9] m;}

        struct mat4i {int[16] m;}
        struct mat4f {float[16] m;}
        struct mat4d {double[16] m;}

        vec2i operator+(vec2i a, vec2i b) {return (vec2i) { .x = (a.x + b.x), .y = (a.y + b.y)};}
        vec2f operator+(vec2f a, vec2f b) {return (vec2f) { .x = (a.x + b.x), .y = (a.y + b.y)};}
        vec2d operator+(vec2d a, vec2d b) {return (vec2d) { .x = (a.x + b.x), .y = (a.y + b.y)};}

        vec2i operator-(vec2i a, vec2i b) {return (vec2i) { .x = (a.x - b.x), .y = (a.y - b.y)};}
        vec2f operator-(vec2f a, vec2f b) {return (vec2f) { .x = (a.x - b.x), .y = (a.y - b.y)};}
        vec2d operator-(vec2d a, vec2d b) {return (vec2d) { .x = (a.x - b.x), .y = (a.y - b.y)};}

        vec2i operator*(vec2i a, vec2i b) {return (vec2i) { .x = (a.x * b.x), .y = (a.y * b.y)};}
        vec2f operator*(vec2f a, vec2f b) {return (vec2f) { .x = (a.x * b.x), .y = (a.y * b.y)};}
        vec2d operator*(vec2d a, vec2d b) {return (vec2d) { .x = (a.x * b.x), .y = (a.y * b.y)};}

        vec2i operator/(vec2i a, vec2i b) {return (vec2i) { .x = (a.x / b.x), .y = (a.y / b.y)};}
        vec2f operator/(vec2f a, vec2f b) {return (vec2f) { .x = (a.x / b.x), .y = (a.y / b.y)};}
        vec2d operator/(vec2d a, vec2d b) {return (vec2d) { .x = (a.x / b.x), .y = (a.y / b.y)};}

        vec3i operator+(vec3i a, vec3i b) {return (vec3i) { .x = (a.x + b.x), .y = (a.y + b.y), .z = (a.z + b.z)};}
        vec3f operator+(vec3f a, vec3f b) {return (vec3f) { .x = (a.x + b.x), .y = (a.y + b.y), .z = (a.z + b.z)};}
        vec3d operator+(vec3d a, vec3d b) {return (vec3d) { .x = (a.x + b.x), .y = (a.y + b.y), .z = (a.z + b.z)};}

        vec3i operator-(vec3i a, vec3i b) {return (vec3i) { .x = (a.x - b.x), .y = (a.y - b.y), .z = (a.z - b.z)};}
        vec3f operator-(vec3f a, vec3f b) {return (vec3f) { .x = (a.x - b.x), .y = (a.y - b.y), .z = (a.z - b.z)};}
        vec3d operator-(vec3d a, vec3d b) {return (vec3d) { .x = (a.x - b.x), .y = (a.y - b.y), .z = (a.z - b.z)};}

        vec3i operator*(vec3i a, vec3i b) {return (vec3i) { .x = (a.x * b.x), .y = (a.y * b.y), .z = (a.z * b.z)};}
        vec3f operator*(vec3f a, vec3f b) {return (vec3f) { .x = (a.x * b.x), .y = (a.y * b.y), .z = (a.z * b.z)};}
        vec3d operator*(vec3d a, vec3d b) {return (vec3d) { .x = (a.x * b.x), .y = (a.y * b.y), .z = (a.z * b.z)};}

        vec3i operator/(vec3i a, vec3i b) {return (vec3i) { .x = (a.x / b.x), .y = (a.y / b.y), .z = (a.z / b.z)};}
        vec3f operator/(vec3f a, vec3f b) {return (vec3f) { .x = (a.x / b.x), .y = (a.y / b.y), .z = (a.z / b.z)};}
        vec3d operator/(vec3d a, vec3d b) {return (vec3d) { .x = (a.x / b.x), .y = (a.y / b.y), .z = (a.z / b.z)};}

        vec4i operator+(vec4i a, vec4i b) {return (vec4i) { .x = (a.x + b.x), .y = (a.y + b.y), .z = (a.z + b.z), .w = (a.w + b.w)};}
        vec4f operator+(vec4f a, vec4f b) {return (vec4f) { .x = (a.x + b.x), .y = (a.y + b.y), .z = (a.z + b.z), .w = (a.w + b.w)};}
        vec4d operator+(vec4d a, vec4d b) {return (vec4d) { .x = (a.x + b.x), .y = (a.y + b.y), .z = (a.z + b.z), .w = (a.w + b.w)};}

        vec4i operator-(vec4i a, vec4i b) {return (vec4i) { .x = (a.x - b.x), .y = (a.y - b.y), .z = (a.z - b.z), .w = (a.w - b.w)};}
        vec4f operator-(vec4f a, vec4f b) {return (vec4f) { .x = (a.x - b.x), .y = (a.y - b.y), .z = (a.z - b.z), .w = (a.w - b.w)};}
        vec4d operator-(vec4d a, vec4d b) {return (vec4d) { .x = (a.x - b.x), .y = (a.y - b.y), .z = (a.z - b.z), .w = (a.w - b.w)};}

        vec4i operator*(vec4i a, vec4i b) {return (vec4i) { .x = (a.x * b.x), .y = (a.y * b.y), .z = (a.z * b.z), .w = (a.w * b.w)};}
        vec4f operator*(vec4f a, vec4f b) {return (vec4f) { .x = (a.x * b.x), .y = (a.y * b.y), .z = (a.z * b.z), .w = (a.w * b.w)};}
        vec4d operator*(vec4d a, vec4d b) {return (vec4d) { .x = (a.x * b.x), .y = (a.y * b.y), .z = (a.z * b.z), .w = (a.w * b.w)};}

        vec4i operator/(vec4i a, vec4i b) {return (vec4i) { .x = (a.x / b.x), .y = (a.y / b.y), .z = (a.z / b.z), .w = (a.w / b.w)};}
        vec4f operator/(vec4f a, vec4f b) {return (vec4f) { .x = (a.x / b.x), .y = (a.y / b.y), .z = (a.z / b.z), .w = (a.w / b.w)};}
        vec4d operator/(vec4d a, vec4d b) {return (vec4d) { .x = (a.x / b.x), .y = (a.y / b.y), .z = (a.z / b.z), .w = (a.w / b.w)};}

        bool operator==(vec2i a, vec2i b) {return (a.x == b.x) && (a.y == b.y);}
        bool operator==(vec2f a, vec2f b) {return (a.x == b.x) && (a.y == b.y);}
        bool operator==(vec2d a, vec2d b) {return (a.x == b.x) && (a.y == b.y);}

        bool operator==(vec3i a, vec3i b) {return (a.x == b.x) && (a.y == b.y) && (a.z == b.z);}
        bool operator==(vec3f a, vec3f b) {return (a.x == b.x) && (a.y == b.y) && (a.z == b.z);}
        bool operator==(vec3d a, vec3d b) {return (a.x == b.x) && (a.y == b.y) && (a.z == b.z);}

        bool operator==(vec4i a, vec4i b) {return (a.x == b.x) && (a.y == b.y) && (a.z == b.z) && (a.w == b.w);}
        bool operator==(vec4f a, vec4f b) {return (a.x == b.x) && (a.y == b.y) && (a.z == b.z) && (a.w == b.w);}
        bool operator==(vec4d a, vec4d b) {return (a.x == b.x) && (a.y == b.y) && (a.z == b.z) && (a.w == b.w);}

        bool operator!=(vec2i a, vec2i b) {return (a.x != b.x) || (a.y != b.y);}
        bool operator!=(vec2f a, vec2f b) {return (a.x != b.x) || (a.y != b.y);}
        bool operator!=(vec2d a, vec2d b) {return (a.x != b.x) || (a.y != b.y);}

        bool operator!=(vec3i a, vec3i b) {return (a.x != b.x) || (a.y != b.y) || (a.z != b.z);}
        bool operator!=(vec3f a, vec3f b) {return (a.x != b.x) || (a.y != b.y) || (a.z != b.z);}
        bool operator!=(vec3d a, vec3d b) {return (a.x != b.x) || (a.y != b.y) || (a.z != b.z);}

        bool operator!=(vec4i a, vec4i b) {return (a.x != b.x) || (a.y != b.y) || (a.z != b.z) || (a.w != b.w);}
        bool operator!=(vec4f a, vec4f b) {return (a.x != b.x) || (a.y != b.y) || (a.z != b.z) || (a.w != b.w);}
        bool operator!=(vec4d a, vec4d b) {return (a.x != b.x) || (a.y != b.y) || (a.z != b.z) || (a.w != b.w);}

        vec2i operator+(vec2i a, float b) {return (vec2i) { .x = (a.x + b), .y = (a.y + b)};}
        vec2f operator+(vec2f a, float b) {return (vec2f) { .x = (a.x + b), .y = (a.y + b)};}
        vec2d operator+(vec2d a, double b) {return (vec2d) { .x = (a.x + b), .y = (a.y + b)};}

        vec2i operator-(vec2i a, float b) {return (vec2i) { .x = (a.x - b), .y = (a.y - b)};}
        vec2f operator-(vec2f a, float b) {return (vec2f) { .x = (a.x - b), .y = (a.y - b)};}
        vec2d operator-(vec2d a, double b) {return (vec2d) { .x = (a.x - b), .y = (a.y - b)};}

        vec2i operator*(vec2i a, float b) {return (vec2i) { .x = (a.x * b), .y = (a.y * b)};}
        vec2f operator*(vec2f a, float b) {return (vec2f) { .x = (a.x * b), .y = (a.y * b)};}
        vec2d operator*(vec2d a, double b) {return (vec2d) { .x = (a.x * b), .y = (a.y * b)};}

        vec2i operator/(vec2i a, float b) {return (vec2i) { .x = (a.x / b), .y = (a.y / b)};}
        vec2f operator/(vec2f a, float b) {return (vec2f) { .x = (a.x / b), .y = (a.y / b)};}
        vec2d operator/(vec2d a, double b) {return (vec2d) { .x = (a.x / b), .y = (a.y / b)};}

        vec3i operator+(vec3i a, float b) {return (vec3i) { .x = (a.x + b), .y = (a.y + b), .z = (a.z + b)};}
        vec3f operator+(vec3f a, float b) {return (vec3f) { .x = (a.x + b), .y = (a.y + b), .z = (a.z + b)};}
        vec3d operator+(vec3d a, double b) {return (vec3d) { .x = (a.x + b), .y = (a.y + b), .z = (a.z + b)};}

        vec3i operator-(vec3i a, float b) {return (vec3i) { .x = (a.x - b), .y = (a.y - b), .z = (a.z - b)};}
        vec3f operator-(vec3f a, float b) {return (vec3f) { .x = (a.x - b), .y = (a.y - b), .z = (a.z - b)};}
        vec3d operator-(vec3d a, double b) {return (vec3d) { .x = (a.x - b), .y = (a.y - b), .z = (a.z - b)};}

        vec3i operator*(vec3i a, float b) {return (vec3i) { .x = (a.x * b), .y = (a.y * b), .z = (a.z * b)};}
        vec3f operator*(vec3f a, float b) {return (vec3f) { .x = (a.x * b), .y = (a.y * b), .z = (a.z * b)};}
        vec3d operator*(vec3d a, double b) {return (vec3d) { .x = (a.x * b), .y = (a.y * b), .z = (a.z * b)};}

        vec3i operator/(vec3i a, float b) {return (vec3i) { .x = (a.x / b), .y = (a.y / b), .z = (a.z / b)};}
        vec3f operator/(vec3f a, float b) {return (vec3f) { .x = (a.x / b), .y = (a.y / b), .z = (a.z / b)};}
        vec3d operator/(vec3d a, double b) {return (vec3d) { .x = (a.x / b), .y = (a.y / b), .z = (a.z / b)};}

        vec4i operator+(vec4i a, float b) {return (vec4i) { .x = (a.x + b), .y = (a.y + b), .z = (a.z + b), .w = (a.w + b)};}
        vec4f operator+(vec4f a, float b) {return (vec4f) { .x = (a.x + b), .y = (a.y + b), .z = (a.z + b), .w = (a.w + b)};}
        vec4d operator+(vec4d a, double b) {return (vec4d) { .x = (a.x + b), .y = (a.y + b), .z = (a.z + b), .w = (a.w + b)};}

        vec4i operator-(vec4i a, float b) {return (vec4i) { .x = (a.x - b), .y = (a.y - b), .z = (a.z - b), .w = (a.w - b)};}
        vec4f operator-(vec4f a, float b) {return (vec4f) { .x = (a.x - b), .y = (a.y - b), .z = (a.z - b), .w = (a.w - b)};}
        vec4d operator-(vec4d a, double b) {return (vec4d) { .x = (a.x - b), .y = (a.y - b), .z = (a.z - b), .w = (a.w - b)};}

        vec4i operator*(vec4i a, float b) {return (vec4i) { .x = (a.x * b), .y = (a.y * b), .z = (a.z * b), .w = (a.w * b)};}
        vec4f operator*(vec4f a, float b) {return (vec4f) { .x = (a.x * b), .y = (a.y * b), .z = (a.z * b), .w = (a.w * b)};}
        vec4d operator*(vec4d a, double b) {return (vec4d) { .x = (a.x * b), .y = (a.y * b), .z = (a.z * b), .w = (a.w * b)};}

        vec4i operator/(vec4i a, float b) {return (vec4i) { .x = (a.x / b), .y = (a.y / b), .z = (a.z / b), .w = (a.w / b)};}
        vec4f operator/(vec4f a, float b) {return (vec4f) { .x = (a.x / b), .y = (a.y / b), .z = (a.z / b), .w = (a.w / b)};}
        vec4d operator/(vec4d a, double b) {return (vec4d) { .x = (a.x / b), .y = (a.y / b), .z = (a.z / b), .w = (a.w / b)};}

        vec2i operator+(float a, vec2i b) {return (vec2i) { .x = (a + b.x), .y = (a + b.y)};}
        vec2f operator+(float a, vec2f b) {return (vec2f) { .x = (a + b.x), .y = (a + b.y)};}
        vec2d operator+(double a, vec2d b) {return (vec2d) { .x = (a + b.x), .y = (a + b.y)};}

        vec3i operator+(float a, vec3i b) {return (vec3i) { .x = (a + b.x), .y = (a + b.y), .z = (a + b.z)};}
        vec3f operator+(float a, vec3f b) {return (vec3f) { .x = (a + b.x), .y = (a + b.y), .z = (a + b.z)};}
        vec3d operator+(double a, vec3d b) {return (vec3d) { .x = (a + b.x), .y = (a + b.y), .z = (a + b.z)};}

        vec4i operator+(float a, vec4i b) {return (vec4i) { .x = (a + b.x), .y = (a + b.y), .z = (a + b.z), .w = (a + b.w)};}
        vec4f operator+(float a, vec4f b) {return (vec4f) { .x = (a + b.x), .y = (a + b.y), .z = (a + b.z), .w = (a + b.w)};}
        vec4d operator+(double a, vec4d b) {return (vec4d) { .x = (a + b.x), .y = (a + b.y), .z = (a + b.z), .w = (a + b.w)};}

        vec2i operator-(float a, vec2i b) {return (vec2i) { .x = (a - b.x), .y = (a - b.y)};}
        vec2f operator-(float a, vec2f b) {return (vec2f) { .x = (a - b.x), .y = (a - b.y)};}
        vec2d operator-(double a, vec2d b) {return (vec2d) { .x = (a - b.x), .y = (a - b.y)};}

        vec3i operator-(float a, vec3i b) {return (vec3i) { .x = (a - b.x), .y = (a - b.y), .z = (a - b.z)};}
        vec3f operator-(float a, vec3f b) {return (vec3f) { .x = (a - b.x), .y = (a - b.y), .z = (a - b.z)};}
        vec3d operator-(double a, vec3d b) {return (vec3d) { .x = (a - b.x), .y = (a - b.y), .z = (a - b.z)};}

        vec4i operator-(float a, vec4i b) {return (vec4i) { .x = (a - b.x), .y = (a - b.y), .z = (a - b.z), .w = (a - b.w)};}
        vec4f operator-(float a, vec4f b) {return (vec4f) { .x = (a - b.x), .y = (a - b.y), .z = (a - b.z), .w = (a - b.w)};}
        vec4d operator-(double a, vec4d b) {return (vec4d) { .x = (a - b.x), .y = (a - b.y), .z = (a - b.z), .w = (a - b.w)};}

        vec2i operator*(float a, vec2i b) {return (vec2i) { .x = (a * b.x), .y = (a * b.y)};}
        vec2f operator*(float a, vec2f b) {return (vec2f) { .x = (a * b.x), .y = (a * b.y)};}
        vec2d operator*(double a, vec2d b) {return (vec2d) { .x = (a * b.x), .y = (a * b.y)};}

        vec3i operator*(float a, vec3i b) {return (vec3i) { .x = (a * b.x), .y = (a * b.y), .z = (a * b.z)};}
        vec3f operator*(float a, vec3f b) {return (vec3f) { .x = (a * b.x), .y = (a * b.y), .z = (a * b.z)};}
        vec3d operator*(double a, vec3d b) {return (vec3d) { .x = (a * b.x), .y = (a * b.y), .z = (a * b.z)};}

        vec4i operator*(float a, vec4i b) {return (vec4i) { .x = (a * b.x), .y = (a * b.y), .z = (a * b.z), .w = (a * b.w)};}
        vec4f operator*(float a, vec4f b) {return (vec4f) { .x = (a * b.x), .y = (a * b.y), .z = (a * b.z), .w = (a * b.w)};}
        vec4d operator*(double a, vec4d b) {return (vec4d) { .x = (a * b.x), .y = (a * b.y), .z = (a * b.z), .w = (a * b.w)};}

        vec2i operator/(float a, vec2i b) {return (vec2i) { .x = (a / b.x), .y = (a / b.y)};}
        vec2f operator/(float a, vec2f b) {return (vec2f) { .x = (a / b.x), .y = (a / b.y)};}
        vec2d operator/(double a, vec2d b) {return (vec2d) { .x = (a / b.x), .y = (a / b.y)};}

        vec3i operator/(float a, vec3i b) {return (vec3i) { .x = (a / b.x), .y = (a / b.y), .z = (a / b.z)};}
        vec3f operator/(float a, vec3f b) {return (vec3f) { .x = (a / b.x), .y = (a / b.y), .z = (a / b.z)};}
        vec3d operator/(double a, vec3d b) {return (vec3d) { .x = (a / b.x), .y = (a / b.y), .z = (a / b.z)};}

        vec4i operator/(float a, vec4i b) {return (vec4i) { .x = (a / b.x), .y = (a / b.y), .z = (a / b.z), .w = (a / b.w)};}
        vec4f operator/(float a, vec4f b) {return (vec4f) { .x = (a / b.x), .y = (a / b.y), .z = (a / b.z), .w = (a / b.w)};}
        vec4d operator/(double a, vec4d b) {return (vec4d) { .x = (a / b.x), .y = (a / b.y), .z = (a / b.z), .w = (a / b.w)};}

        vec2i v_normal(vec2i v) {return (v * (1 / (float) sqrt(v.x*v.x + v.y*v.y)));}
        vec2f v_normal(vec2f v) {return (v * (1 / (float) sqrt(v.x*v.x + v.y*v.y)));}
        vec2d v_normal(vec2d v) {return (v * (1 / (double) sqrt(v.x*v.x + v.y*v.y)));}

        vec3i v_normal(vec3i v) {return (v * (1 / (float) sqrt(v.x*v.x + v.y*v.y + v.z*v.z)));}
        vec3f v_normal(vec3f v) {return (v * (1 / (float) sqrt(v.x*v.x + v.y*v.y + v.z*v.z)));}
        vec3d v_normal(vec3d v) {return (v * (1 / (double) sqrt(v.x*v.x + v.y*v.y + v.z*v.z)));}

        vec4i v_normal(vec4i v) {return (v * (1 / (float) sqrt(v.x*v.x + v.y*v.y + v.z*v.z + v.w*v.w)));}
        vec4f v_normal(vec4f v) {return (v * (1 / (float) sqrt(v.x*v.x + v.y*v.y + v.z*v.z + v.w*v.w)));}
        vec4d v_normal(vec4d v) {return (v * (1 / (double) sqrt(v.x*v.x + v.y*v.y + v.z*v.z + v.w*v.w)));}

        void v_normal(vec2i *v) {
            float len = (float) sqrt(v->x*v->x + v->y*v->y);
            v->x = (int)(v->x * len);
            v->y = (int)(v->y * len);
        }
        void v_normal(vec2f *v) {
            float len = (float) sqrt(v->x*v->x + v->y*v->y);
            v->x = (v->x * len);
            v->y = (v->y * len);
        }
        void v_normal(vec2d *v) {
            double len = (double) sqrt(v->x*v->x + v->y*v->y);
            v->x = (v->x * len);
            v->y = (v->y * len);
        }

        void v_normal(vec3i *v) {
            float len = (float) sqrt(v->x*v->x + v->y*v->y + v->z*v->z);
            v->x = (int)(v->x * len);
            v->y = (int)(v->y * len);
            v->z = (int)(v->z * len);
        }
        void v_normal(vec3f *v) {
            float len = (float) sqrt(v->x*v->x + v->y*v->y + v->z*v->z);
            v->x = (v->x * len);
            v->y = (v->y * len);
            v->z = (v->z * len);
        }
        void v_normal(vec3d *v) {
            double len = (double) sqrt(v->x*v->x + v->y*v->y + v->z*v->z);
            v->x = (v->x * len);
            v->y = (v->y * len);
            v->z = (v->z * len);
        }

        void v_normal(vec4i *v) {
            float len = (float) sqrt(v->x*v->x + v->y*v->y + v->z*v->z + v->w*v->w);
            v->x = (int)(v->x * len);
            v->y = (int)(v->y * len);
            v->z = (int)(v->z * len);
            v->w = (int)(v->w * len);
        }
        void v_normal(vec4f *v) {
            float len = (float) sqrt(v->x*v->x + v->y*v->y + v->z*v->z + v->w*v->w);
            v->x = (v->x * len);
            v->y = (v->y * len);
            v->z = (v->z * len);
            v->w = (v->w * len);
        }
        void v_normal(vec4d *v) {
            double len = (double) sqrt(v->x*v->x + v->y*v->y + v->z*v->z + v->w*v->w);
            v->x = (v->x * len);
            v->y = (v->y * len);
            v->z = (v->z * len);
            v->w = (v->w * len);
        }

        void m_print(mat2i m) {
            printf("2x2 Int Matrix {\n");
            printf("    %d, %d\n", m.m[0], m.m[1]);
            printf("    %d, %d\n", m.m[2], m.m[3]);
            printf("}\n");
        }
        void m_print(mat2f m) {
            printf("2x2 Float Matrix {\n");
            printf("    %f, %f\n", m.m[0], m.m[1]);
            printf("    %f, %f\n", m.m[2], m.m[3]);
            printf("}\n");
        }
        void m_print(mat2d m) {
            printf("2x2 Double Matrix {\n");
            printf("    %lf, %lf\n", m.m[0], m.m[1]);
            printf("    %lf, %lf\n", m.m[2], m.m[3]);
            printf("}\n");
        }

        void m_print(mat3i m) {
            printf("3x3 Int Matrix {\n");
            printf("    %d, %d, %d\n", m.m[0], m.m[1], m.m[2]);
            printf("    %d, %d, %d\n", m.m[3], m.m[4], m.m[5]);
            printf("    %d, %d, %d\n", m.m[6], m.m[7], m.m[8]);
            printf("}\n");
        }
        void m_print(mat3f m) {
            printf("3x3 Float Matrix {\n");
            printf("    %f, %f, %f\n", m.m[0], m.m[1], m.m[2]);
            printf("    %f, %f, %f\n", m.m[3], m.m[4], m.m[5]);
            printf("    %f, %f, %f\n", m.m[6], m.m[7], m.m[8]);
            printf("}\n");
        }
        void m_print(mat3d m) {
            printf("3x3 Double Matrix {\n");
            printf("    %lf, %lf, %lf\n", m.m[0], m.m[1], m.m[2]);
            printf("    %lf, %lf, %lf\n", m.m[3], m.m[4], m.m[5]);
            printf("    %lf, %lf, %lf\n", m.m[6], m.m[7], m.m[8]);
            printf("}\n");
        }

        void m_print(mat4i m) {
            printf("4x4 Int Matrix {\n");
            printf("    %d, %d, %d, %d\n", m.m[0], m.m[1], m.m[2], m.m[3]);
            printf("    %d, %d, %d, %d\n", m.m[4], m.m[5], m.m[6], m.m[7]);
            printf("    %d, %d, %d, %d\n", m.m[8], m.m[9], m.m[10], m.m[11]);
            printf("    %d, %d, %d, %d\n", m.m[12], m.m[13], m.m[14], m.m[15]);
            printf("}\n");
        }
        void m_print(mat4f m) {
            printf("4x4 Float Matrix {\n");
            printf("    %f, %f, %f, %f\n", m.m[0], m.m[1], m.m[2], m.m[3]);
            printf("    %f, %f, %f, %f\n", m.m[4], m.m[5], m.m[6], m.m[7]);
            printf("    %f, %f, %f, %f\n", m.m[8], m.m[9], m.m[10], m.m[11]);
            printf("    %f, %f, %f, %f\n", m.m[12], m.m[13], m.m[14], m.m[15]);
            printf("}\n");
        }
        void m_print(mat4d m) {
            printf("4x4 Double Matrix {\n");
            printf("    %lf, %lf, %lf, %lf\n", m.m[0], m.m[1], m.m[2], m.m[3]);
            printf("    %lf, %lf, %lf, %lf\n", m.m[4], m.m[5], m.m[6], m.m[7]);
            printf("    %lf, %lf, %lf, %lf\n", m.m[8], m.m[9], m.m[10], m.m[11]);
            printf("    %lf, %lf, %lf, %lf\n", m.m[12], m.m[13], m.m[14], m.m[15]);
            printf("}\n");
        }


    }
}