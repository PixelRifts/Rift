// stb_hexwave - v0.5 - public domain, initial release 2021-04-01
//
// A flexible anti-aliased (bandlimited) digital audio oscillator.
//
// This library generates waveforms of a variety of shapes made of
// line segments. It does not do envelopes, LFO effects, etc.; it
// merely tries to solve the problem of generating an artifact-free
// morphable digital waveform with a variety of spectra, and leaves
// it to the user to rescale the waveform and mix multiple voices, etc.
// Notes:
//
//   Optionally performs memory allocation during initialization,
//   never allocates otherwise.
// Usage:
//
//   Initialization:
//
//     hexwave_init(32,16,NULL); // read "header section" for alternatives
//
//   Create oscillator:
//
//     HexWave* osc = malloc(sizeof(*osc)); // or "new HexWave", or declare globally or on stack
//     hexwave_create(osc, reflect_flag, peak_time, half_height, zero_wait);
//       see "Waveform shapes" below for the meaning of these parameters
//
//   Generate audio:
//
//     hexwave_generate_samples(output, number_of_samples, osc, oscillator_freq)
//       where:
//         output is a buffer where the library will store floating point audio samples
//         number_of_samples is the number of audio samples to generate
//         osc is a pointer to a Hexwave
//         oscillator_freq is the frequency of the oscillator divided by the sample rate
//
//       The output samples will continue from where the samples generated by the
//       previous hexwave_generate_samples() on this oscillator ended.
//
//   Change oscillator waveform:
//
//     hexwave_change(osc, reflect_flag, peak_time, half_height, zero_wait);
//       can call in between calls to hexwave_generate_samples
//
// Waveform shapes:
//
//   All waveforms generated by hexwave are constructed from six line segments
//   characterized by 3 parameters.
//
//   See demonstration: https://www.youtube.com/watch?v=hsUCrAsDN-M
//
//                 reflect=0                          reflect=1
//
//           0-----P---1                        0-----P---1    peak_time = P
//                 .     1                            .     1
//                /\_    :                           /\_    :
//               /   \_  :                          /   \_  :
//              /      \.H                         /      \.H  half_height = H
//             /       | :                        /       | :
//       _____/        |_:___               _____/        | :       _____
//           .           :   \        |         .         | :      /
//           .           :    \       |         .         | :     /
//           .           :     \     _/         .         \_:    /
//           .           :      \  _/           .           :_  /
//           .          -1       \/             .          -1 \/
//       0 - Z - - - - 1                    0 - Z - - - - 1   zero_wait = Z
//
//    Classic waveforms:
//                               peak    half    zero
//                     reflect   time   height   wait
//      Sawtooth          1       0       0       0
//      Square            1       0       1       0
//      Triangle          1       0.5     0       0
//
//    Some waveforms can be produced in multiple ways, which is useful when morphing
//    into other waveforms, and there are a few more notable shapes:
//
//                               peak    half    zero
//                     reflect   time   height   wait
//      Sawtooth          1       1      any      0
//      Sawtooth (8va)    1       0      -1       0
//      Triangle          1       0.5     0       0
//      Square            1       0       1       0
//      Square            0       0       1       0
//      Triangle          0       0.5     0       0
//      Triangle          0       0      -1       0
//      AlternatingSaw    0       0       0       0
//      AlternatingSaw    0       1      any      0
//      Stairs            0       0       1       0.5
//
//    The "Sawtooth (8va)" waveform is identical to a sawtooth wave with 2x the
//    frequency, but when morphed with other values, it becomes an overtone of
//    the base frequency.
//
//  Morphing waveforms:
//
//    Sweeping peak_time morphs the waveform while producing various spectra.
//    Sweeping half_height effectively crossfades between two waveforms; useful, but less exciting.
//    Sweeping zero_wait produces a similar effect no matter the reset of the waveform,
//        a sort of high-pass/PWM effect where the wave becomes silent at zero_wait=1.
//
//    You can trivially morph between any two waveforms from the above table
//    which only differ in one column.
//
//    Crossfade between classic waveforms:
//                                            peak     half    zero
//        Start         End         reflect   time    height   wait
//        -----         ---         -------   ----    ------   ----
//        Triangle      Square         0       0      -1..1    0
//        Saw           Square         1       0       0..1    0
//        Triangle      Saw            1       0.5     0..2    0
//
//    The last morph uses uses half-height values larger than 1, which means it will
//    be louder and the output should be scaled down by half to compensate, or better
//    by dynamically tracking the morph: volume_scale = 1 - half_height/4
//
//    Non-crossfade morph between classic waveforms, most require changing
//    two parameters at the same time:
//                                           peak     half    zero
//      Start         End         reflect    time    height   wait
//      -----         ---         -------    ----    ------   ----
//      Square        Triangle      any      0..0.5   1..0     0
//      Square        Saw            1       0..1     1..any   0
//      Triangle      Saw            1     0.5..1     0..-1    0
//
//    Other noteworthy morphs between simple shapes:
//                                                            peak     half    zero
//      Start           Halfway       End          reflect    time    height   wait
//      -----           ---------     ---          -------    ----    ------   ----
//      Saw (8va,neg)                Saw (pos)        1       0..1      -1      0
//      Saw (neg)                    Saw (pos)        1       0..1       0      0
//      Triangle                     AlternatingSaw   0       0..1      -1      0
//      AlternatingSaw  Triangle     AlternatingSaw   0       0..1       0      0
//      Square                       AlternatingSaw   0       0..1       1      0
//      Triangle        Triangle     AlternatingSaw   0       0..1    -1..1     0
//      Square                       AlternatingSaw   0       0..1     1..0     0
//      Saw (8va)       Triangle     Saw              1       0..1    -1..1     0
//      Saw (neg)                    Saw (pos)        1       0..1     0..1     0
//      AlternatingSaw               AlternatingSaw   0       0..1     0..any   0
//
//   The last entry is noteworthy because the morph from the halfway point to either
//   endpoint sounds very different. For example, an LFO sweeping back and forth over
//   the whole range will morph between the middle timbre and the AlternatingSaw
//   timbre in two different ways, alternating.
//
//   Entries with "any" for half_height are whole families of morphs, as you can pick
//   any value you want as the endpoint for half_height.
//
//   You can always morph between any two waveforms with the same value of 'reflect'
//   by just sweeping the parameters simultaneously. There will never be artifacts
//   and the result will always be useful, if not necessarily what you want.
//
//   You can vary the sound of two-parameter morphs by ramping them differently,
//   e.g. if the morph goes from t=0..1, then square-to-triangle looks like:
//        peak_time   = lerp(t, 0, 0.5)
//        half_height = lerp(t, 1, 0  )
//   but you can also do things like:
//        peak_time   = lerp(smoothstep(t), 0, 0.5)
//        half_height = cos(PI/2 * t)
//
// How it works:
//
//   hexwave use BLEP to bandlimit discontinuities and BLAMP
//   to bandlimit C1 discontinuities. This is not polyBLEP
//   (polynomial BLEP), it is table-driven BLEP. It is
//   also not minBLEP (minimum-phase BLEP), as that complicates
//   things for little benefit once BLAMP is involved.
//
//   The previous oscillator frequency is remembered, and when
//   the frequency changes, a BLAMP is generated to remove the
//   C1 discontinuity, which reduces artifacts for sweeps/LFO.
//
//   Changes to an oscillator timbre using hexwave_change() actually
//   wait until the oscillator finishes its current cycle. All
//   waveforms with non-zero "zero_wait" settings pass through 0
//   and have 0-slope at the start of a cycle, which means changing
//   the settings is artifact free at that time. (If zero_wait is 0,
//   the code still treats it as passing through 0 with 0-slope; it'll
//   apply the necessary fixups to make it artifact free as if it does
//   transition to 0 with 0-slope vs. the waveform at the end of
//   the cycle, then adds the fixups for a non-0 and non-0 slope
//   at the start of the cycle, which cancels out if zero_wait is 0,
//   and still does the right thing if zero_wait is 0 when the
//   settings are updated.)
//
//   BLEP/BLAMP normally requires overlapping buffers, but this
//   is hidden from the user by generating the waveform to a
//   temporary buffer and saving the overlap regions internally
//   between calls. (It is slightly more complicated; see code.)
//
//   By design all shapes have 0 DC offset; this is one reason
//   hexwave uses zero_wait instead of standard PWM.
//
//   The internals of hexwave could support any arbitrary shape
//   made of line segments, but I chose not to expose this
//   generality in favor of a simple, easy-to-use API.

cinsert "#define STB_HEXWAVE_IMPLEMENTATION";
cinclude "std/stb_hexwave.h";

native struct HexWave;

native void hexwave_init(int width, int oversample, float* user_buffer);
//       user_buffer: pass in same parameter as passed to hexwave_init

native void hexwave_shutdown(float* user_buffer);
// see docs above for description
//
//   reflect is tested as 0 or non-zero
//   peak_time is clamped to 0..1
//   half_height is not clamped
//   zero_wait is clamped to 0..1

native void hexwave_create(HexWave* hex, int reflect, float peak_time, float half_height, float zero_wait);
// see docs above for description
//
//   reflect is tested as 0 or non-zero
//   peak_time is clamped to 0..1
//   half_height is not clamped
//   zero_wait is clamped to 0..1

native void hexwave_change(HexWave* hex, int reflect, float peak_time, float half_height, float zero_wait);
// see docs

native void hexwave_generate_samples(float* output, int num_samples, HexWave* hex, float freq);
//            output: buffer where the library will store generated floating point audio samples
// number_of_samples: the number of audio samples to generate
//               osc: pointer to a Hexwave initialized with 'hexwave_create'
//   oscillator_freq: frequency of the oscillator divided by the sample rate

native struct HexWaveParameters;

native void hex_add_oversamples_bleplike(float* output, float time_since_transition, float scale, float* data);

native void hex_blep(float* output, float time_since_transition, float scale);
native void hex_blamp(float* output, float time_since_transition, float scale);

native struct hexvert;

native void hexwave_generate_linesegs(hexvert* vert, HexWave* hex, float dt);
//            vert: pointer to an array of hexvert structs